Aprende programación con C


Aprende programación con C
________________


________________


Aprende programación con C
Desarrolla tus propias aplicaciones
Jose Vicente Carratalá Sanchis
________________
________________














	Para Amelia
	

________________








________________
 Tabla de contenidos
1. Prólogo        12
2. Introducción        15
2.1. Presentación y enfoque de la publicación        16
2.2. La creación de aplicaciones como disciplina universal        16
2.3. Acerca del autor        18
2.4. La metodología de aprendizaje        18
2.5. Los ejercicios de cada lección        19
2.6. El ejercicio del curso        19
2.7. Cómo aprender a programar        21
2.8. Lenguajes de alto nivel y lenguajes de bajo nivel        25
2.9. Prerrequisitos de este curso.        26
2.10. Requerimientos de hardware y de software.        26
2.11. Qué es un programa        27
2.12. Qué es un lenguaje de programación        28
2.13. El núcleo del lenguaje de programación, y las librerías        29
2.14. Acerca del lenguaje que se trata en este libro        30
2.15. Ejercicios propuestos en este libro        31
2.15.1. Ejercicios individuales y ejercicio del curso        31
2.15.2. Cabecera del código        31
3. ¡Hola mundo!        34
3.1. El origen de “Hola, Mundo”        35
3.2. Cómo empezar a programar        35
3.3. Editores de código y entornos de desarrollo        36
3.3.1. Gedit        39
3.3.2. Notepad++ (Windows)        40
3.3.3. DevCPP (Windows)        41
3.3.4. Adobe Brackets        42
3.4. Tu primer programa        43
3.5. Ejecutando el código        45
3.5.1. Cómo compilar el codigo: Windows        46
3.5.2. Cómo compilar el código: Linux        48
3.5.3. Cómo compilar el código : macOS        50
3.6. Compilación de “Hola Mundo”        54
4. Arrancando el proyecto del curso        55
4.1. Creación del proyecto del curso        56
4.2. Reglas sintácticas        58
4.2.1. Las terminaciones de línea        58
4.2.2. Las sangrías        59
4.2.3. Buenas prácticas        60
4.2.4. Uso de mayúsculas y minúsculas        60
4.2.5. Claridad entre los nombres de las variables.        61
5. Comentarios        63
5.1. Comentarios de una única línea        64
5.2. Comentarios de varias líneas        66
5.3. Proyecto del curso        68
6. Errores        70
6.1. Diferentes tipos de errores        73
6.1.1. Introducción a los errores        73
6.1.2. Errores sintácticos        74
6.1.3. Errores lógicos        76
7. Operaciones de impresión de datos en pantalla        78
7.1. ¿Que son?        79
7.2. Ejercicio del curso        81
8. Variables        84
8.1. ¿Qué son las variables?        85
8.2. Tipos de datos        85
8.3. Variables de tipo numérico        86
8.4. Texto        88
8.5. Reglas de declaración de Identificadores de variables        90
8.6. Soporte para Unicode        93
8.7. Listado de palabras reservadas de C        96
8.8. Aplicación sobre el ejercicio El curso        96
8.9. Constantes        98
8.10. Ejercicio del curso        100
9. Entrada de información en un programa        104
9.1. Atrapando caracteres con getchar        105
9.2. Atrapando cadenas de caracteres con scanf        106
9.3. Ejercicio del curso        108
10. Operadores        111
10.1. Qué son los operadores        112
10.2. Operadores aritméticos        112
10.3. Orden de precedencia en las operaciones aritméticas.        114
10.4. Operadores de comparación        115
10.5. Operadores lógicos        119
10.6. Operadores de incremento y decremento        123
10.7. operadores abreviados        124
11. Estructuras de control        128
11.1. ¿Qué son las estructuras de control?        129
11.2. Estructuras condicionales        129
11.2.1. La estructura condicional if        130
11.2.2. Anidación de las estructuras de control condicionales        131
11.2.3. La estructura de control condicional switch        133
11.2.4. El caso default        135
11.2.5. La estructura de control condicional else if        137
11.2.6. Ejercicio del curso:        138
11.3. Estructuras de bucle        140
11.3.1. La estructura de control for.        141
11.3.2. la estructura de control While        147
11.3.3. El bucle Do While        151
11.3.4. la estructura de control for en arreglos (for each)        153
12. Arreglos        157
12.1. ¿Qué son las estructuras de datos?        158
12.2. Arreglos        159
12.3. Arreglos multidimensionales        160
13. Estructuras        163
13.1. Que son las estructuras?        164
13.2. ¿Qué es la programación orientada a objetos?        164
13.3. Que son las estructuras?        166
13.4. Declaración de estructuras        166
13.5. Creación de estructuras        168
13.6. Estructuras dentro de matrices        172
13.7. Ejercicio del curso        173
13.8. Ejercicio del curso        177
14. Funciones        181
14.1. ¿Qué son las funciones?        182
14.2. Declaración de funciones        183
14.3. Uso de funciones        186
14.4. Funciones con parámetros        187
14.5. Funciones con múltiples parámetros        190
14.6. El ámbito de las variables:        191
14.7. Ejercicio del curso        192
14.8. Externalización del contenido.        196
14.9. Ejercicio del curso:        199
15. Persistencia en archivos        219
15.1. Persistencia, ¿qué es?        220
15.2. Persistencia en archivos de texto        221
15.3. escritura de archivos.        221
15.4. El cierre de los recursos.        222
15.5. Cómo leer un archivo        223
15.6. Ejercicio del curso        225
15.7. Sobre la instrucción de partir cadenas a matriz        232
16. Librería de tiempo        236
16.1. Control del tiempo        237
16.2. Clicks de ejecución de procesador        240
16.3. Tiempo        241
16.4. Proyecto del curso        241
17. Estado final del ejercicio        249
17.1. Estructura del proyecto        250
17.2. Contenido del proyecto        251
17.2.1. Archivo principal        251
17.2.2. Actualizar Registro        252
17.2.3. Buscar Registro        254
17.2.4. Obtener la fecha        255
17.2.5. Datos de partida        256
17.2.6. Eliminar Registro        257
17.2.7. Guardar Datos        258
17.2.8. Introducir Registro        259
17.2.9. Listar los registros        261
17.2.10. Menú Principal        261
17.2.11. Recuperar Datos        263
17.3. Ejecución        265
17.3.1. Compilación        265
17.3.2. Ejecución        265
17.3.3. El programa en funcionamiento        266
18. Epílogo        272


1. Prólogo
________________


Más de 50 años después de su creación, C sigue siendo uno de los lenguajes de programación más utilizados en el sector informático, incluso por delante de aquellos lenguajes que, basados en el propio C, se crearon, años o décadas después, para reemplazarlo.
C no es especialmente fácil de utilizar, especialmente si lo comparamos con otros lenguajes de alto nivel - pero nos permite crear aplicaciones de alto rendimiento, y obtener un alto grado de control sobre los recursos que utilizamos. Por ello, es un lenguaje de programación imprescindible en aquellos entornos o contextos en los que se requiere rendimiento y control.
Con el lenguaje C puedes crear programas informáticos. Crear programas informáticos es hoy más relevante que nunca, en la medida en la que la informática nos rodea y está presente en muchas de las facetas de nuestras vidas - y, al parecer, esta tendencia seguirá al alza. 
Así pues, cuando consultas tu terminal móvil, su sistema operativo está programado en C. Cuando consultas una web, el sistema operativo del servidor que te la proporciona está programado en C, y la propia aplicación de servidor web (Apache, en la mayoría de los casos), también.  Muchas de las aplicaciones de escritorio que utilizas están programadas en C. Sin darte cuenta, muchas de las herramientas informáticas que usas en tu día a día están construidas con el lenguaje C. 
Este libro te ofrece la posibilidad de poder unirte a esas personas que crean herramientas informáticas. El objetivo de este libro consiste en proporcionarte los conocimientos necesarios para que tú también puedas crear herramientas informáticas en base a tus propias ideas y proyectos, porque no todo está inventado, porque los mejores inventos están todavía por llegar, y porque hay muchas personas que tienen muy buenas ideas, pero les falta la forma de convertirlas en realidad. 
C tiene fama de ser un lenguaje que no es particularmente fácil de aprender. La propuesta que hace este libro consiste en realizar un paseo guiado por las principales características de este lenguaje de programación, con el objetivo de hacer que la construcción de programas informáticos sea algo sencillo, ameno y comprensible.
________________
2. Introducción
________________
2.1. Presentación y enfoque de la publicación
Desde el principio de mi carrera profesional he tenido la oportunidad de compaginar, de manera continuada, el desarrollo de proyectos para clientes con acciones formativas de distinta índole, que me han permitido estar en contacto, de forma simultánea, tanto con la realidad del mercado, como con aquellas personas que inician su camino,muchas veces partiendo desde cero, en el mundo de la programación, esperando llegar a esa realidad del mercado. 
Así que mi trabajo, desde hace ya más de 20 años, consiste básicamente en conseguir que esas personas que inician su camino en el aprendizaje de la programación lleguen, de la forma más fácil y más directa posible, a conseguir ese que es su sueño, que es trabajar de programadores. 
Esta publicación es el resultado de esa experiencia acumulada tanto desde el punto de vista del desarrollo práctico de proyectos para clientes con necesidades concretas, o lo que es lo mismo, lo que podríamos conocer como “el mundo real” y por otra parte, también desde el punto de vista formativo. 
2.2. La creación de aplicaciones como disciplina universal
Si bien hace años la programación de aplicaciones informáticas era una disciplina reservada para personal técnico y, sobre todo, reservada a aquellas personas que han consagrado su vida profesional al mundo informático en cualquiera de sus formas, en los últimos años estamos conociendo la tendencia consistente en transformar la programación de aplicaciones informáticas como una materia transversal a diferentes disciplinas.
Esto quiere decir que el desarrollo de aplicaciones informáticas ya no es un proceso exclusivo de los llamados profesionales informáticos, sino que muchos otros profesionales tienen la necesidad de desarrollar aplicaciones informáticas para realizar tareas y automatizar procesos en su vida profesional.
No se trata de una cuestión de quitar trabajo al clásico desarrollador, si no, de alguna manera, de popularizar y democratizar el proceso de escritura de aplicaciones. tanto es así, que desde hace unos pocos años se empieza a hablar del concepto de introducir la programación en ciclos de estudio elemental para que, desde la infancia, los niños sean capaces de adquirir esa destreza, ya que todo parece indicar que la tendencia de que la sociedad necesita cada vez más programas informáticos va a seguir al alza, y por tanto, es una buena apuesta que las futuras generaciones adquieran esa competencia lo más tempranamente posible.
Aprender a desarrollar aplicaciones informáticas, sin embargo, en ocasiones, no es sencillo. Aunque esto depende en gran medida de las características de cada lenguaje de programación, en definitiva, independientemente del lenguaje que se escoja, en el momento en el que se empieza a desarrollar en un lenguaje de programación concreto, hay una serie de reglas de sintaxis y reglas lógicas que deben ser aprendidas.
A lo largo de los años, como formador, en la búsqueda de material docente para mis alumnos, he encontrado muchas publicaciones que sirven como referencia, en el sentido de que explican los conceptos clave de un lenguaje de programación pero no explican el proceso de desarrollo de una aplicación informática. Por otra parte, muchas veces los ejemplos que he visto en esas publicaciones tienen sentido cuando llevas años programando, pero pueden ser difíciles de entender por un usuario que empieza a programar.
Esa es exactamente mi motivación a la hora de escribir esta publicación. desde que empecé mi carrera profesional, tanto como desarrollador, pero sobre todo como docente, mi objetivo es hacer que lo difícil se convierta en fácil, mi objetivo es hacer llegar la programación a todo el mundo, y demostrar que aprender a programar depende más de la constancia que de la inteligencia, por parte del alumno, pero también ayuda tener un profesor que explica el contenido a aprender de la forma más clara y más didáctica posible. 
Lo que se pretende con esta publicación es ofrecer una experiencia de entrada al lenguaje de programación qué se trata a lo largo de este libro, es decir, no solo que el lector aprenda a programar, sino que lo haga de la forma más fácil, más agradable, más sencilla posible, pero también, por supuesto, que aprenda todos los conocimientos clave necesarios para desarrollar su potencial, y aprovechar las herramientas que pone a su disposición el lenguaje de programación concreto que en esta publicación se trata.
2.3. Acerca del autor
Jose Vicente Carratala es un desarrollador, diseñador, y formador.
Profesor externo en la Universidad politécnica de Valencia, y autor de títulos formativos para video2brain y LinkedIn Learning, tiene amplia experiencia tanto en la impartición de cursos presenciales, como en la generación de contenidos de formación online.
Como fundador del estudio de desarrollo JOCARSA, desarrolla proyectos que aúnan las facetas del diseño 3D y el desarrollo de aplicaciones interactivas, estableciendo una retroalimentación bidireccional entre las facetas de desarrollo de proyectos y la formación.
El contenido de esta publicación refleja no solo los años de experiencia formativa en contenidos teóricos, sino también la experiencia de la aplicación práctica del desarrollo de aplicaciones en proyectos para clientes en el día a día
2.4. La metodología de aprendizaje
Esta publicación propone, a la vez que se explica cada una de las unidades didácticas, una serie de ejercicios prácticos para realizar, en los que el lector debe poner a prueba los conocimientos mostrados. Cada una de las unidades contiene dos bloques de ejercicios, cada uno con su objetivo particular:
Por una parte, se propone un ejercicio en el que se practica única y exclusivamente los conocimientos correspondientes a la unidad actual, aunque evidentemente, en muchas ocasiones se hace uso de conocimientos adquiridos en elecciones anteriores.
Por otra parte, se propone un ejercicio continuo que se va desarrollando a lo largo de las elecciones, cuyo objetivo es mostrar cómo se unen las diferentes partes entre sí, y cuál es el proceso general de crear un programa informático.
2.5. Los ejercicios de cada lección
En muchas ocasiones, cuando se busca algo de información acerca de un aspecto concreto de un lenguaje de programación, acabamos encontrando ejemplos de 200 o 300 líneas de código, que, además de contener la respuesta a nuestra necesidad de información, contienen además una gran cantidad de código que no necesitamos o que no estábamos buscando, o que, en definitiva, dificultan el acceso a la información concreta que estamos buscando.
De esta forma, conseguir una respuesta se convierte en un proceso en el que tenemos que apartar toda la paja para llegar al oro. Es por esto que, en esta publicación, en cada una de las lecciones, se demuestra aquello que se está explicando con el ejemplo más sencillo, más compacto, y más nuclear posible, para exponer y demostrar únicamente el concepto propio de la unidad, con el objetivo, también, de que el lector tenga una biblioteca de ejemplos de código completamente segmentados.
2.6. El ejercicio del curso
Esta publicación pretende ser algo más que un manual de referencia de un lenguaje de programación.
Muchas veces, cuando leemos manuales acerca de un lenguaje de programación, se nos comunica el significado y la utilidad de cada una de las partes, pero finalmente se falla en darnos una visión de conjunto, que nos permita saber cuál es la relación entre las diferentes partes, y en definitiva, cuál es el proceso completo y global de desarrollar un programa informático con ese lenguaje, desde el principio hasta el final.
Es por eso que en esta publicación se propone un ejercicio que se va desarrollando a lo largo de cada una de las unidades y los capítulos del libro, de forma que, en cada unidad, el lector puede encontrar siempre dos aplicaciones prácticas del conocimiento teórico:
* Por una parte se trata de ofrecer una visión práctica del conocimiento concreto de cada una de las unidades, ofreciendo un ejercicio específico y aislado de lo que se está aprendiendo en esa unidad concreta
* Por otra parte, se propone un ejercicio continuo a lo largo del libro, que se va alimentando para aplicar el conocimiento de cada una de las partes del libro.
Es de esta forma como, al finalizar la publicación, el lector no solo tiene una vista concreta de cada una de las partes del lenguaje de programación, sino también una visión global acerca de cómo nace, se desarrolla, y se completa un programa informático.
Para implementar el ejercicio práctico se ha escogido el clásico y arquetípico ejercicio de la agenda. La razón didáctica de escoger este ejemplo, es que permite ilustrar tanto el guardado y almacenaje de datos, como su tratamiento, a nivel de inserción, lectura, búsqueda, eliminación, y edición. Este flujo de trabajo es típico y característico de cualquier aplicación empresarial comercial, con lo cual, los conocimientos aplicados para desarrollar este ejercicio son directamente aplicables a cualquier otro tipo de programa informático basado en el tratamiento de datos.
Al final, el funcionamiento de una agenda es muy similar al funcionamiento de una base de datos de películas, al funcionamiento de un sistema de gestión de la relación con el cliente, al sistema de gestión empresarial, o a cualquier otro sistema dentro del entorno empresarial.
Es por esto que, cuando el lector vaya avanzando a lo largo del ejercicio basado en crear una agenda, realmente debería estar pensando en ese momento como aplicar los conocimientos ofrecidos al desarrollo del software que desea desarrollar.
2.7. Cómo aprender a programar
De todas aquellas unidades y de todos aquellos bloques didácticos de los que se compone esta publicación, en mi opinión, el más importante, con diferencia, es este punto.
Después de haber leído el contenido de esta publicación, es muy probable que olvides aquellos puntos que no uses a diario, pero sin embargo, me gustaría que lo que voy a exponer a continuación, lo tuvieras siempre presente, tanto durante tu proceso de aprendizaje, a lo largo de la lectura de esta publicación, como incluso después, mucho después.
El objetivo de esta publicación es hacerte fácil el proceso de aprender a desarrollar programas informáticos, pero, hasta cierto punto, desarrollar programas informáticos tiene un cierto nivel de dificultad a día de hoy, y es previsible que lo siga teniendo durante unos cuantos años. Por esto, se requiere por tu parte una actitud muy concreta con respecto al proceso del aprendizaje. es casi más importante que estés preparado para aprender, que los conocimientos técnicos concretos de los cuales se compone esta publicación.
En los más de 20 años que llevo impartiendo formación, he visto que la constancia es mucho más importante que la inteligencia o la valía a la hora de no solo aprender a programar, sino de desarrollar una carrera exitosa como desarrollador. No es posible aprender a programar sin cometer errores, eso es un concepto básico que debe quedar claro lo antes posible . Teóricamente no debería ser un concepto tan innovador con respecto a todo aquello que hasta ahora has aprendido en tu vida. Nadie nace sabiendo caminar, el proceso de aprender a caminar es largo, Ningún niño aprende a caminar de repente, ningún niño aprende a caminar sin antes caerse. Ningún niño habla de repente, todos los niños hablan poco a poco, y al principio, cometen muchos errores, que van siendo corregidos, hasta perfeccionar el habla. El ser humano, en definitiva, en cualquiera de sus facetas, funciona así. En la primera vez que hacemos algo, con toda probabilidad, aunque tengamos un día a nuestro lado, siempre lo vamos a hacer mal. sin embargo, también forma parte de nuestra naturaleza humana  levantarnos cuando nos caemos, aprender de nuestros errores, y seguir avanzando y progresando.
Finalmente, como suele decirse, la repetición lleva a la perfección, es decir, en prácticamente cualquier faceta de nuestra actividad humana, con toda probabilidad la primera vez que realizamos una nueva tarea lo hacemos mal, pero si tenemos la paciencia y la constancia de fijarnos en nuestros errores y aprender de ellos, si repetimos esa tarea suficientes veces, primero la llegamos a hacer bien, y en segundo término la llegamos a hacer con un nivel elevado de perfección.
Exactamente lo mismo ocurre con el proceso de aprendizaje de programación . a lo largo de los años, he observado a una gran mayoría de alumnos que simplemente aceptan este proceso de aprendizaje de la misma forma que han aprendido otras muchas capacidades y pericias a lo largo de su vida, pero también he encontrado algunos alumnos que, por algún motivo, pretenden aprender a programar sin cometer errores.
Pues que quede claro lo antes posible, especialmente en el mundo de la programación no es en absoluto posible aprender a programar sin cometer errores. los errores son una parte imprescindible del proceso de aprendizaje humano en general, y de la programación en particular.
Muchos lenguajes de programación tienen una sintaxis muy concreta, y son poco permisivos con respecto al lenguaje humano. esto quiere decir que, cuando nos comunicamos con otro humano, aunque las reglas de comunicación no sean exactamente las mismas Expresemos en alguna palabra incorrectamente el mensaje, nuestro interlocutor es capaz de inferir el significado mediante el contexto o mediante otras herramientas, y en definitiva, ese error en la comunicación no impide que el receptor entienda correctamente el mensaje.
Sin embargo, los lenguajes de programación son finalmente interpretados por máquinas, y las máquinas no tienen esa capacidad que tiene el ser humano de inferir o extrapolar aquellas partes de conocimiento que nosotros no indicamos, o de subsanar aquellos errores en la comunicación que podamos cometer.
De esta forma, hay un concepto de programación que debe quedar claro lo antes posible los puntos si tenemos una aplicación informática que tiene 500 líneas de código, y dentro de esas líneas de código cometemos un solo error sintáctico, por pequeño que sea, el programa no funcionará en absoluto. así de estricta es la programación de aplicaciones informáticas.
Cometer errores, por tanto, es inevitable, desde el punto de vista de que es muy difícil escribir 500, 1500, o 5000 líneas de código de un programa informático y no cometer ningún error desde el punto de vista de las reglas sintácticas que el intérprete espera recibir.
Así pues, una vez que hayamos aceptado esto, deberemos entender que aprender a programar sin errores no es un objetivo realista. Nuestro objetivo, por contra, es aceptar que vamos a cometer errores, probablemente vamos a cometer muchos de ellos, y deberemos tener una mentalidad siempre abierta a la aceptación de esta realidad, y al hecho de que, cuando cometemos errores, deberemos encontrarlos de la forma más rápida posible, y deberemos solucionarlos para continuar programando punto.
Esta es, en mi opinión, la actitud que te llevará a convertirte en un desarrollador o una desarrolladora,
Con el paso del tiempo, evidentemente, con la práctica, es cuando vas a perfeccionar tu capacidad de desarrollar programas, e inevitablemente, cada vez cometerás menos errores, hasta que, virtualmente, quizás, llegues a programar sin cometer errores.
Los errores, al principio, probablemente serán sencillos. una gran cantidad de alumnos que tengo que cometen errores de programación, Los cometen con los terminadores de instrucción, es decir, por ejemplo, en los lenguajes Derivados de c, simplemente se olvidan de poner el . y, al final de la instrucción, o de la línea, o en definitiva de las dos cosas a la vez, si ubicamos una instrucción en cada línea de código.
Otro consejo muy importante desde el punto de vista del aprendizaje de lenguajes de programación, es desarrollar poco a poco, y no escribir muchas líneas de código de una sola vez.
Si escribimos 20, 40, 100 líneas de código de una sola vez, es muy probable que tengamos errores dentro de esas líneas, encontrarlos será una tarea bastante difícil.
En lugar de eso, especialmente cuando estamos aprendiendo a programar, es mucho más recomendable que escribamos unas pocas líneas de código, las mínimas imprescindibles, y que probemos el programa antes de continuar.
Si da un error llegado ese punto, lo recomendable no es continuar, sino buscar y reparar ese error antes de continuar. es decir, evitar que la bola de nieve se vaya haciendo cada vez más grande, controlando los errores, y no continuando hasta asegurar que nuestro programa está en funcionamiento.
Otro consejo clave consiste en echarle siempre un vistazo al resultado de la compilación. El compilador, generalmente, no suele dar pistas acerca de la naturaleza del error o de los errores que hemos cometido.
Esto al principio confunde mucho al estudiante, ya que está en nuestra naturaleza humana el hecho de que no nos guste ser conscientes de nuestros propios errores. es por esto que, inconscientemente, tendemos a ignorar los mensajes de error que aparecen al compilar o al interpretar el código, simplemente, porque el mensaje se puede resumir en comillas, lo has hecho mal comillas.
Sin embargo, debemos tragarnos nuestro orgullo, y dedicarnos a leer esos mensajes de error, ya que en ellos no solo se encuentra el problema, sino muchas veces, también la solución.
Tras un tiempo programando, finalmente, te acostumbraras a percibir esos mensajes de error como una parte no sólo natural sino absolutamente necesaria en el proceso de depuración de errores de un programa informático, y el desarrollo de ese hábito, te permitirá avanzar mucho más rápido en tus habilidades como programador o programadora.
2.8. Lenguajes de alto nivel y lenguajes de bajo nivel
Frecuentemente, en foros, o en discusiones Programación, oirás estos términos, alto nivel y bajo nivel aplicados para referirse a lenguajes de programación.
Son términos un poco confusos desde el . de vista en que no coinciden, en connotaciones, con otros tantos conceptos que te puedas encontrar en la vida real.
En prácticamente cualquier otro ámbito, algo que es de alto nivel tiene categoría, y algo que es de bajo nivel no la tiene. sin embargo, esto no se aplica en absoluto a los lenguajes de programación no porque se usen los términos al contrario, sino porque su aplicación no tiene nada que ver.
La bajeza o la altura del nivel únicamente tiene que ver, en el mundo de la programación, con la proximidad al lenguaje máquina . los lenguajes de bajo nivel son aquellos que, por su sintaxis, o por su manera de operar, están relativamente próximos al lenguaje binario de la máquina, es decir, realizan pocas abstracciones para el ser humano.
Por el contrario, evidentemente, los lenguajes de alto nivel son aquellos que están más cerca del lenguaje natural del ser humano que del lenguaje artificial de la máquina y por tanto, introducen más abstracciones que, en un momento dado, deberán ser convertidas finalmente a lenguaje máquina, que es quien ejecuta el programa informático al final.
Una vez más, no podemos decir que los lenguajes de bajo nivel sean mejores ni peores que los lenguajes de alto nivel. lo que desde luego sí que debe quedar claro, es que hay diferencias entre ellos, equiparables según diferentes criterios.
Por ejemplo, los lenguajes de alto nivel son más fáciles de aprender por regla general que los lenguajes de bajo nivel, ya que están más cerca del lenguaje humano que del lenguaje de la máquina. por mencionar otro criterio, también se suele decir que los lenguajes de bajo nivel suelen ser más eficientes y más potentes que los lenguajes de alto nivel, ya que están más cercanos al lenguaje natural de la máquina, y por tanto, por regla general, están más optimizados para con la ejecución pura y dura de instrucciones por parte de la Unidad Central de Proceso existente en cada computadora.
2.9. Prerrequisitos de este curso.
Este curso no tiene conocimientos previos requeridos, ya que empieza la enseñanza del lenguaje de programación que se muestra en esta publicación completamente desde cero. Es por esto que no se requiere experiencia ni conocimiento previo en lenguajes o entornos de programación, aunque evidentemente, siempre son bienvenidos. Se requiere, eso sí, destrezas básicas informáticas, en cuanto a manejo de sistema operativo a nivel de usuario.
2.10. Requerimientos de hardware y de software.
El objeto de esta publicación es enseñar a crear lenguajes de programación de aplicaciones informáticas.
Es por esto que, evidentemente, para poder practicar y ejecutar los ejercicios que se proponen a lo largo de las unidades didácticas, es necesario que el lector disponga de un ordenador portátil o de sobremesa, con sistema operativo Windows, Linux, macOS.
hasta la fecha, en el momento de escribir esta publicación, no es frecuente poder encontrar compiladores o intérpretes para este lenguaje de programación en dispositivos móviles, tales como teléfonos, o tabletas, aunque estos dispositivos están evolucionando muy rápidamente, por lo que es posible que, para cuando leas esta publicación, ya existan alternativas.
Por otra parte, siempre existe una opción que es usar intérpretes en la nube. Es decir, aplicaciones web que nos permiten acceder a las capacidades de un intérprete o un compilador a través de un sitio web y que, por tanto, pueden usarse desde dispositivos móviles donde en principio no sería posible compilar en el propio dispositivo.
2.11. Qué es un programa
Programa informático está compuesto por una serie de instrucciones, típicamente escritas en lenguaje máquina, o en cualquier otro lenguaje que una computadora pueda entender, e introduce cambios tanto en la parte lógica como en la parte física de la máquina.
Frecuentemente, estos cambios introducidos en los estados de la máquina son de alguna utilidad para el ser humano, bien para aquel que está creando el programa, o bien para los usuarios destinatarios del uso de la aplicación informática.
Otra definición de que es un programa informático, la podemos encontrar en que es un conjunto de cálculos que realiza una computadora, en base a una entrada de información, usualmente proporcionada por el ser humano, y ofrece un resultado después de realizar cálculos sobre esta entrada.
Evidentemente, todas estas definiciones son generales, y en gran medida bastante abstractas, ya que el concepto de lo que es y lo que hace un programa informático, ya de por sí es amplio, se amplifica más cada día que pasa.
En definitiva, y para dar una descripción más humana y más cercana, lo primero que debemos tener en cuenta es que las computadoras son máquinas programables, es decir, máquinas que, a diferencia de una lavadora o un horno, no tienen un comportamiento preestablecido, sino que pueden tener múltiples comportamientos.
Un programa informático, al final, es un conjunto de instrucciones que le dicen a la máquina como debe comportarse, qué acciones debe tomar, en base a la información que el ser humano le haya proporcionado.
2.12. Qué es un lenguaje de programación
Las máquinas están construidas con procesadores que, finalmente, funcionan con dos estados: encendido y apagado.
De esta forma, el lenguaje nativo en el que habla la máquina es el código binario, y todas las instrucciones que se ejecutan dentro de una máquina, finalmente están escritas en el lenguaje nativo del hardware, es decir, está escrito en base a combinaciones de unos y ceros.
Así que el lenguaje binario es el más bajo de los lenguajes, entendiendo por bajos los lenguajes que están cerca del núcleo de la máquina.
Es un lenguaje muy eficiente, pero sin embargo, muy inaccesible al ser humano, desde el punto de vista en que el ser humano pueda escribir programas directamente en este lenguaje de programación.
Los lenguajes de programación llamados de alto nivel, es decir, lenguajes que no están tan cerca del núcleo de la máquina, pero están más cerca del ser humano, introducen abstracciones y simplificaciones tal que permiten a una persona común escribir programas en un lenguaje fácilmente entendible.
2.13. El núcleo del lenguaje de programación, y las librerías
Con el fin de propiciar la extensibilidad de los lenguajes de programación, cualquier lenguaje moderno queda separado entre el núcleo, y las librerías.
De esta manera, cualquier lenguaje de programación puede crecer fácilmente a través del uso de librerías, que extienden la funcionalidad del núcleo.
En la gran mayoría de lenguajes de programación, existe, de hecho, una serie de librerías que suelen venir adjuntas al núcleo en las instalaciones por defecto, y una cantidad mucho más pasta de librerías que en un momento dado, podemos añadir al conjunto del núcleo y las librerías iniciales.
En cuanto a la librería inicial, hay lenguajes que precarga esta librería, de forma que, sin que el usuario lo perciba, puede usar cualquier instrucción de cualquiera de estas librerías simplemente invocandola.
Estos lenguajes son más sencillos desde el punto de vista didáctico, ya que nos permiten empezar directamente a programar usando una gran cantidad de instrucciones siempre ocuparnos por el concepto de importación de librería.
Hay otros lenguajes en los que, sin embargo, aunque el núcleo venga acompañado de un conjunto de librerías, estas librerías no vienen necesariamente activadas, y hay que activarlas a demanda, es decir, únicamente deben activarse aquellas librerías que realmente vayan a usarse al abrigo del programa.
Saber que instrucciones contiene cada librería es todo un reto que requiere paciencia, constancia, y práctica.
Los lenguajes que no importan todas las librerías por defecto suelen ser más eficientes en cuanto a consumo de memoria, ya que no cargan más instrucciones de los que realmente van a utilizar, y por tanto, acaban por no usar más memoria de la estrictamente necesaria.
En el caso del lenguaje que nos ocupa en esta publicación, entra dentro de esos lenguajes que incorporan una serie de librerías iniciales, pero prácticamente ninguna viene activada por defecto.
Es por esto, y dado que esta cuestión suele suponer un bache a los usuarios noveles, deberemos prestar siempre atención a la importación de librerías necesarias según las instrucciones que usemos dentro del programa que estamos desarrollando.
2.14. Acerca del lenguaje que se trata en este libro
Cuando, a mediados del siglo XX, el ser humano inventó las primeras computadoras programables, estas inmensas máquinas al principio se programaban usando el propio lenguaje de relés activados o desactivados.
Éste lenguaje, llamado lenguaje binario, ya que los reales originalmente solo tenían dos posiciones, activo e inactivo, también recibe el nombre de lenguaje máquina, ya que es el lenguaje que habla nativa mente la computadora.
En pocos años, y a la vista de la incomodidad y lo poco práctico de desarrollar programas utilizando el lenguaje de la máquina, tampoco intuitivo para el ser humano, surgió la necesidad de crear abstracciones de un nivel más alto, lenguajes que el ser humano pudiera comprender de una manera más fácil que el código binario, y le permitirán ser más productivo A la hora de escribir programas informáticos.
De esta manera nació el lenguaje ensamblador, que si bien establece algunas abstracciones con respecto al lenguaje máquina, finalmente es un lenguaje de un nivel de dificultad similar.
Así pues, unos pocos años después, surgieron los primeros lenguajes llamados de alto nivel, lenguajes mucho más cerca del lenguaje humano, que del lenguaje de la máquina.
Evidentemente, al tiempo que surgieron estos lenguajes, también surgió la necesidad de un programa compilador, es decir, una manera de traducir el lenguaje humano de alto nivel, al lenguaje de la máquina en bajo nivel.
Así es como surgieron una familia de lenguajes de programación, de los cuales se es el más importante que ha llegado hasta nuestros días, por su potencia a la vez que facilidad, Y por tener un buen balance entre facilidad de aprendizaje, rendimiento, y prestaciones.
2.15. Ejercicios propuestos en este libro
2.15.1. Ejercicios individuales y ejercicio del curso
A lo largo de este libro se presentan una serie de ejercicios individuales, cuyo contenido se va introduciendo de forma aditiva en dos ejercicios contínuos. A través de los ejercicios individuales se pretende mostrar al lector el significado y la aplicación de cada uno de los conceptos mostrados a través de las unidades didácticas, y en los ejercicios contínuos, se pretende mostrar cómo esos conocimientos se pueden usar como bloques de construcción para crear programas más complejos.
2.15.2. Cabecera del código
Los ejercicios individuales no presentarán cabecera, significando que el usuario los podrá guardar en cualquier ubicación dentro de su ordenador. Podrán presentarse como el siguiente ejemplo:
#include <stdio.h>

int main(int argc, char *argv[]) {
        printf("Hola Mundo \n");
        return 0;
}
	Sin embargo, los programas que formen parte de los ejercicios contínuos del curso, sí que presentarán una cabecera, en la que se indicará la ubicación (carpetas) donde deberá estar almacenado el código, y el nombre del propio archivo ,como en este ejemplo:
📂proyectodelcurso/  📄main.c
	/* Programa agenda
por Jose Vicente Carratala */
#include <stdio.h>

int main(int argc, char *argv[]) {
   // Mensaje de bienvenida
        printf("Programa agenda v1.0 \n");
        printf("Selecciona una opción \n");
        return 0;
}
	En el ejemplo anterior, el archivo estará guardado dentro de la carpeta llamada “proyecto1”:
📂proyectodelcurso
Y deberá tener el nombre “main.c”
📄main.c
















________________




3. ¡Hola mundo!
________________


3.1. El origen de “Hola, Mundo”
Mientras que no está claro cuál es el origen exacto de esta expresión, es un hecho que, desde hace décadas, es costumbre que el primer programa que una persona crea en el lenguaje de programación que esté aprendiendo, consista en expresar “Hola mundo”.
Personalmente, me parece una costumbre muy bonita. Cuando una persona aprende a programar, generalmente lo hace con la voluntad y la intención de dar a conocer al mundo los programas que aprenda a crear. Así que, crear un primer programa tal que lo primero que haga sea saludar al mundo, siempre me ha parecido un fantástico primer paso en la dirección correcta.
Además de todo esto, en aquellos cursos que he impartido de forma presencial, que han sido muchísimos, siempre he visto la luz en los ojos de mis alumnos al ejecutar su primer “Hola mundo”, por lo cual, no habiendo creado yo la tendencia de crear un primer programa de estas características, siempre he visto bien adherirse a la tendencia.
3.2. Cómo empezar a programar
Antes de empezar a desarrollar el contenido de esta publicación, por ejemplo a partir del siguiente capítulo, en el cual se discuten operaciones concretas, tales como por ejemplo escribir cosas por pantalla, o en definitiva empezar a realizar operaciones, es necesario describir los primeros pasos que hay que realizar para poder tener un espacio de trabajo concreto.
Estas operaciones varían dependiendo del lenguaje de programación en el que se esté trabajando.
Por ejemplo, hay lenguajes de programación, como Python, donde únicamente es necesario abrir un archivo nuevo, no importa el número del archivo, únicamente importa eso sí que su extensión sea la correcta, y podemos escribir directamente una instrucción de inversión en pantalla, algo parecido A esto:
Sin embargo, hay otros lenguajes de programación, como por ejemplo Java, englobado dentro de la familia de lenguajes que usan el paradigma de la programación orientada a objetos, como único paradigma de programación, donde antes de poder empezar a escribir nuestro código, es necesario crear una clase inicial.
Adicionalmente, pueden existir otras reglas en cuanto a la nomenclatura del archivo. Es por esto, que, es importante, antes de poder empezar a desarrollar los conceptos del lenguaje de programación, saber qué es lo necesario para poder efectivamente empezar a escribir.
3.3. Editores de código y entornos de desarrollo
Como hemos visto anteriormente, no es necesario más que un editor de Notas, para poder escribir el código del lenguaje de programación en el que estamos trabajando.
En entornos Unix y Linux, es incluso posible editar programas directamente desde micro editores de texto en línea de comandos.
Por ejemplo, en el sistema operativo Linux, en la distribución Ubuntu, encontramos el editor de texto Nano, que nos permite editar líneas de texto directamente desde la consola.
Esto no solo es posible, sino que desde mi punto de vista, didácticamente, es conveniente, para de alguna manera desmitificar la dificultad en el acceso al lenguaje de programación, y demostrar cómo únicamente con un Block de Notas y un compilador podemos empezar a escribir nuestros propios programas.
Con el paso de los años han ido surgiendo entornos de desarrollo integrados, también conocidos como IDE.
Estos entornos son algo así como editores muy avanzados de texto, que nos ofrecen funcionalidades tales como por ejemplo las siguientes:
* Tienen correctores automáticos de sintaxis, que nos indican dónde pueden encontrarse errores en nuestro código, antes incluso de ejecutarlo.
* Cuando compilamos y ejecutamos el código, y nos da uno o varios errores, las líneas que contienen los errores aparecen resaltadas con algún tipo de coloración, usualmente en rojo.
* El programa detecta cuando estamos utilizando instrucciones pertenecientes a una librería, y nos propone la importación automática de la librería correcta.
* Gestionan muy eficazmente proyectos por carpetas, y múltiples archivos en cada proyecto.
* Generalmente, incluso, son capaces de conectarse a unidades remotas, para poder evitar proyectos de forma colaborativa.
Permiten enlazar fácilmente librerías externas que no están contenidos dentro de la propia colección de librerías por defecto.
Éstos son sólo algunos ejemplos de las ventajas que puede darnos utilizar un entorno de desarrollo integrado.
Es por esto que, en ningún momento quiero ocultar ni la existencia ni la conveniencia de usar un entorno de desarrollo integrado, y aunque en esta publicación no voy a recomendar ningún entorno por encima de otro, simplemente me voy a centrar en el código fuente, que es lo importante.
Lo que es importante para mí es, dejar claro, desde un punto de vista puramente didáctico, que los entornos de desarrollo integrados no son más que herramientas para conseguir un fin. La finalidad es escribir programas, y los entornos de desarrollo integrados no son más que herramientas que, en un momento dado, nos ofrecen facilidades.
Realizo esta aclaración de la forma más clara y sencilla posible, ya que, cuando una persona se aproxima al mundo de la programación, es muy normal que confunda a la herramienta con el objetivo, y que perciba el entorno de desarrollo integrado como una herramienta clave para conseguir el éxito en la programación.
Para ilustrar lo equivocado que, en mi opinión, está ese concepto, yo suelo comparar a los entornos de desarrollo integrados con una caja de herramientas de un carpintero.
Si tienes una buena caja de herramientas, y eres carpintero, probablemente, trabajarás más cómodo.
Pero igualmente, tener una mejor caja perra mientras no te convierte automáticamente en el mejor carpintero.
Con los entornos de desarrollo integrado pasa algo parecido, trabajar con un entorno de desarrollo integrado te hará ser más productivo y te permitirá trabajar más cómodamente, pero no hay que caer en la confusión de que el trabajo lo hace el entorno de desarrollo. El trabajo lo hace el desarrollador, el mérito, el esfuerzo, la responsabilidad, recae sobre el desarrollador, y el entorno no es más que una mera herramienta.
Por último, solo también aconsejar centrarse en aprender el código y no perder demasiado tiempo aprendiendo las particularidades de un entorno de desarrollo, por varios motivos adicionales:
A lo largo del tiempo, a lo largo de los años, he ido viendo como unos entornos desaparecen y otros nuevos aparecen, aunque el código siempre sigue siendo el mismo.
Por otra parte, tal vez estás aprendiendo a programar en el lenguaje de programación que se trata en esta publicación porque, quizás, en un futuro tengas planificado trabajar por cuenta ajena, es decir, incorporarte a una empresa como programador.
Cuando esto ocurra, ten en cuenta que la empresa que te contrata probablemente no utilizará el mismo entorno de desarrollo en el que tú te puedes haber acostumbrado a trabajar.
La moraleja es que, si aprendes el código, si aprendes el lenguaje, luego puedes adaptarte a cualquier entorno de desarrollo, pero si te cansas demasiado con un entorno de desarrollo, luego te puede costar cambiar de entorno, cuando llegue el momento, que en mi opinión, más tarde o más temprano llega.
3.3.1. Gedit
Gedit un editor nativamente asociado al sistema operativo linux, pero que, sin embargo, dispone de binarios ejecutables disponibles tanto para Windows como para macOS
Además de todo esto, podemos encontrar el código fuente en los repositorios habituales de las distribuciones de linux, para, en cualquier caso, poder compilarlo para el sistema operativo que en un momento dado podemos usar,
Este es únicamente un editor de texto, qué incluye soporte para colorear de múltiples lenguajes de programación.
Esto quiere decir que no incorpora ningún tipo de compilador, que debe ser instalado aparte.
La ventaja de este editor, es, obviamente, en primer lugar, que es sumamente ligero, y que es multiplataforma, lo cual nos permite en un momento dado cambiar de un sistema operativo a otro, sin cambiar sustancialmente nuestra metodología de trabajo y el entorno en el que desarrollamos nuestras aplicaciones.
  

3.3.2. Notepad++ (Windows)
Este editor tiene características similares al presentado en el . anterior, incluye algunas ventajas, como por ejemplo la capacidad de plegar código, y es extensible mediante plugins.
Además, las últimas versiones hasta la fecha hacen de este programa una alternativa muy rápida y muy ligera, lo cual siempre viene bien, desde el . de vista de disponer de un programa que es capaz de trabajar rápida y ligeramente con archivos conteniendo miles de líneas de código.
Es, al final, un editor de código, que permite colorear la fuente según diversos lenguajes de programación, pero no incluye ningún tipo de compilador o intérprete con él, y por tanto, estas herramientas deben ser instaladas aparte.
  

3.3.3. DevCPP (Windows)
Este es uno de los primeros entornos qué puedo recomendar, ya que la instalación de base contiene los paquetes esenciales para poder empezar a desarrollar código con el menor coste posible.
Por una parte, incluye un entorno de desarrollo en ventanas, y una instalación del compilador minGW .
Esta instalación está directamente vinculada al editor, de tal forma, que al crear un archivo fuente en el editor, con una simple función de menú, podemos compilar y ejecutar el proyecto en el que estamos trabajando.
Probablemente no es la alternativa más didáctica, desde el . de vista de saber qué es lo que está ocurriendo en todo momento y cuáles son los pasos reales de la compilación de un programa, pero desde luego es una alternativa muy sencilla para empezar a programar, que nos permite preocuparnos únicamente de escribir el código fuente de nuestro programa, y quizás dejar para más adelante los detalles concretos acerca de cómo y quién realiza la compilación.
  

3.3.4. Adobe Brackets
Adobe Brackets es un editor de código multipropósito de la empresa Adobe. Puede descargarse para Windows, macOS y Linux, y es de uso libre. Posee herramientas de coloreado de código con un listado extenso de lenguajes soportados, entre los cuales se encuentra, por supuesto, C.
  

3.4. Tu primer programa
Para empezar a programar, únicamente hace falta un editor de archivos, es decir, un editor de texto plano, donde, en el menor de los casos, se recomienda una aplicación de tipo Block de Notas.
Lo que tendremos que hacer es crear un nuevo archivo dentro del sistema de archivos de nuestro sistema operativo, en una carpeta de nuestra elección, y pondremos al archivo un nombre, intentando evitar espacios, acentos, Eñes, y otros caracteres similares.
Para que más adelante el archivo sea correctamente reconocido por el compilador, deberá tener la extensión. C.
Una vez creado el archivo, podremos abrirlo dentro del programa de edición de Bloc de Notas que estemos utilizando, donde es importante notar que deben evitarse programas que introduzcan formateo adicional al texto, tales como por ejemplo Microsoft Word.
Por lo tanto, los editores mínimos que se recomiendan, son:
* Gedit en Linux
* TextEdit en mac OS (con “texto sin formato”)
* Bloc de notas en Windows
Los ejercicios de este curso se han creado entre Adobe Brackets y Gedit.
una vez dentro del archivo, tenemos que escribir el siguiente código:
#include <stdio.h>

int main(int argc, char *argv[]) {
        printf("Hola Mundo \n");
        return 0;
}
	En el caso del lenguaje de programación concreto que estamos tratando en esta publicación, como podemos comprobar, tenemos que importar una librería inicial que nos permite realizar operaciones de entrada y de salida.
A continuación, introducimos una función principal, que contiene el código que vayamos a ejecutar.
Por último, dentro de las llaves, especificamos cuál es el texto, en forma de instrucciones, que se va a ejecutar.
En este caso es importante notar que el nombre de la función no puede variar, ya que es una palabra reservada dentro del lenguaje.
Dentro de un programa podremos tener tantas funciones como queramos, pero sin embargo siempre deberá haber una, y solo una, llamada a main.c.
Cuando el programa se ejecute, siempre lo hará partiendo desde esta función, como punto de partida, y si es necesario, llamar a todas las demás.
En el ejemplo que nos ocupa en esta sección, estamos desarrollando un programa llamado hola mundo.
Cuando empezamos en un lenguaje de programación, es muy común, es típico entre la comunidad de desarrolladores, utilizar esta sencilla frase, simplemente para comprobar que todo funciona como debe, y que el programa está respondiendo a nuestras instrucciones.
3.5. Ejecutando el código
Una vez que hemos escrito nuestro código, es cuando tenemos que pensar de qué manera lo vamos a ejecutar.
La ejecución varía mucho dependiendo de en qué lenguaje estamos trabajando, ya que, como hemos discutido antes, existen lenguajes compilados, lenguajes conciencia cutáneo contra una máquina virtual, y lenguajes que se interpretan en el momento.
En el caso que nos ocupa, en la gran mayoría de ocasiones, lo que hacemos es compilar nuestro código en un archivo llamado compilado binario ejecutable.
El funcionamiento, por tanto, consiste en trabajar con un programa llamado compilador, que se encarga de transformar nuestro archivo de código fuente en archivo binario.
Lo primero que debemos tener en cuenta, es que este archivo binario depende de la plataforma. Si estamos compilando en Windows, el archivo resultante será el clásico ejecutable. Si estamos compilando en Mac o en Linux, el archivo puede tener una extensión diferente, o directamente no tener extensión.
Lo más importante a remarcar, especialmente con diferencia a los lenguajes de máquina virtual con los lenguajes interpretados, es que los lenguajes combinados, Al generar archivos en varios, dependen completamente del sistema operativo.
Es decir, en el momento en el que generamos un archivo binario a partir de un código fuente, ese archivo binario se genera únicamente compatible con el sistema operativo en el que se ha complicado, y generalmente no es compatible con otros o medios y sistemas operativos.
3.5.1. Cómo compilar el codigo: Windows
Dado que estamos trabajando con un lenguaje de programación que, finalmente, tiene como objetivo generar archivos binarios ejecutables, es necesario disponer de alguna herramienta que transforme el código fuente del programa que hemos desarrollado hasta el momento, y que continuaremos arrollando, a un archivo que tenga las características anteriormente mencionadas, es decir, que sea un archivo binario, y sobre todo, lo más importante, que contenga una serie de instrucciones ejecutables por parte del sistema operativo y por parte de la máquina en la que estemos trabajando en este momento.
Si bien otros sistemas operativos incluyen soportes de serie para poder compilar Nuestros programas, a lo largo del tiempo, parece que la plataforma windows, tan extendida entre los usuarios, ha sido una plataforma en cierta manera elusiva a los compiladores en lenguaje C.
Una teoría para esto es que, de hecho, el propio sistema operativo parece que nos empuja a programar en tecnologías de Microsoft, tales como visual C#, Visual Basic.net, o Visual C + +.
Sin embargo, sea como sea, en este caso, nosotros queremos aprender a programar en c, y queremos hacerlo en el sistema operativo windows. 
Es por esto que la opción recomendada es trabajar con un conjunto de herramientas llamadas MinGW  que permite instalar el compilador gcc más un conjunto de herramientas directamente dentro del sistema operativo Windows.
Podemos descargar este conjunto de herramientas desde la siguiente dirección:
https://www.mingw-w64.org/
A partir de ese momento, es cuando podemos empezar a compilar nuestros programas en c, en el sistema operativo Windows.
Deberemos tener en cuenta que, por defecto, la carpeta de instalación está dentro de la clásica carpeta de Archivos de programa del sistema operativo . será, por tanto, altamente recomendable, establecer una variable de sistema para el archivo ejecutable gcc.exe, de tal forma que lo podamos invocar desde cualquier parte del sistema operativo. En caso contrario, tendríamos que invocarlo llamando al ejecutable del compilador con su ruta absoluta.
Una vez que lo hayamos instalado, y una vez que hayamos declarado esa variable global, para poder ejecutar el compilador desde cualquier parte del sistema operativo, es cuando tendremos que abrir una ventana de símbolo de sistema, navegar hasta la carpeta donde esté nuestro archivo fuente, que supongamos que tiene el nombre mine. c, y ejecutar el siguiente comando:
gcc main.c
	Al realizar esa acción, podremos comprobar que, automáticamente, el compilador, si no hay ningún error, genera el siguiente archivo en nuestro sistema de archivos, en la misma carpeta en la que se encuentra el archivo main. C.
out.exe
	A lo largo de las siguientes unidades aprenderemos que el compilador se puede invocar pasándole parámetros, tales como los que nos permiten indicar cuál es el nombre del archivo de salida, para que ese nombre no se ha escogido automáticamente por el compilador.
De todas formas, especialmente cuando estamos empezando a programar y a compilar nuestros primeros programas, no hay demasiado problema en que el archivo por defecto reciba el nombre out.exe, ya que una vez que ha sido generado, lo podemos renombrar fácilmente.
3.5.2. Cómo compilar el código: Linux
Linux ha sido históricamente una plataforma mucho más receptiva al desarrollo de aplicaciones en C.
De esta forma, supongamos que estamos trabajando en un sistema operativo linux, en una distribución de tipo Debian, y sus distribuciones similares, tales como por ejemplo ubuntu, donde disponemos de sistemas de instalación de paquetes a través de la terminal, de una forma terriblemente sencilla, eso sí, cuando nos hemos acostumbrado a usar en cierta medida está terminal de comandos.
Lo único que tendremos que hacer es entrar en una nueva instancia de la terminal, y poner el siguiente comando:
sudo apt install build-essential
	Deberemos tener en cuenta que la primera instrucción del comando que he introducido anteriormente es una ejecución como superusuario, con lo cual, se nos pedirá una contraseña para confirmar que tenemos permisos para instalar nuevos paquetes de software en el ordenador en el que estemos trabajando.
Si todo ha ido correctamente, después de la instalación, ya podremos compilar cualquier script desde cualquier carpeta del sistema operativo.
Lo único que tendremos que hacer es navegar utilizando esa terminal hasta la carpeta donde esté el script, que, como en el apartado anterior, vamos a suponer que se encuentra dentro de una carpeta de usuario, con el nombre main.c
Una vez que hayamos  entrado dentro de esa carpeta, invocar hemos al siguiente comando
gcc main.c
	Si todo ha ido correctamente, y el archivo que hemos compilado no tiene errores, automáticamente el compilador habrá extraído un archivo llamado:
a.out
	Que será un archivo binario ejecutable a continuación podemos ejecutar directamente este archivo en la terminal, simplemente introduciendo un  punto y una barra antes de llamar al archivo, de la siguiente forma:
./a.out
	Debemos tener en cuenta que en el sistema operativo Linux los archivos ejecutables no tienen la típica extensión exe que encontramos dentro del sistema operativo windows, pero en definitiva, son correspondientes entre sí.
Llegado este punto, también conviene recordar la evidente  incompatibilidad entre diferentes sistemas operativos, y diferentes arquitecturas . en el momento en el que combinamos un programa en c, este programa se compila para ese sistema operativo, y esa arquitectura.
En la práctica, esto quiere decir que un programa compilado en windows, solo será compatible con windows, y no será compatible con Linux ni con macOS, y viceversa.
De la misma forma, compilando el programa usando windows, en la plataforma x86, el archivo compilado no será compatible con el sistema operativo windows, pero la plataforma a rm, o lo que es lo mismo, Windows RT, ya que el sistema operativo será el mismo, pero la plataforma no lo será.
Así que esto nos lleva a la disyuntiva de definir si c es un lenguaje multiplataforma o no lo es.
Lo cierto es que el lenguaje es multiplataforma, desde el . de vista de que el código fuente no está asociado a un sistema operativo concreto Y podemos compilarlo en tanto sistemas como compiladores haya disponibles, pero eso sí, debemos tener en cuenta que tendremos que hacer una nueva compilación para cada uno de los sistemas operativos en los que quedamos ejecutar nuestro archivo binario.
Hay otros lenguajes, sin embargo, que son interpretados o compilan a un binario intermedio, y por tanto no es necesario realizar compilaciones para cada uno de los sistemas operativos.
Por otra parte, una vez introducido el concepto de multiplataforma desde el punto de vista de compilar un binario para cada uno de los sistemas operativos las plataformas, también debemos decir que existen librerías multiplataforma, y existen librerías específicas de plataforma.
De esta forma, el lenguaje en sí mismo es multiplataforma, pero sin embargo, si acabamos usando una librería específica de una plataforma concreta, es posible que nuestro código finalmente no sea tan libre, y esté atado a esa plataforma no ya por el propio lenguaje, sino por la elección de nuestras librerías.
Mi recomendación, por tanto, es analizar la compatibilidad que esperamos de nuestros programas, y realizar una correcta elección de librerías en base a este criterio.
3.5.3. Cómo compilar el código : macOS
Desde el punto de vista de los comandos de la terminal, el funcionamiento en el sistema operativo de Apple es muy similar, por no decir prácticamente igual, al funcionamiento en el sistema operativo Linux.
En primer lugar, debemos descargar un conjunto de herramientas de compilación, que podremos invocar abriendo una terminal y llamando al comando gcc:
Last login: Thu Jan  5 09:08:00 on console
MacBook-Pro-de-Jose:~ josevicente$ gcc
	En el caso de que el compilador estuviera previamente instalado, obtendremos un mensaje de error en pantalla al no haber especificado el archivo de entrada (el archivo a compilar):
Last login: Thu Jan  5 09:08:00 on console
MacBook-Pro-de-Jose:~ josevicente$ gcc
clang: error: no input files
MacBook-Pro-de-Jose:~ josevicente$ 
	En el caso de que no estén instaladas, aparecerá este mensaje:
  
A continuación aceptaremos los contratos de licencia correspondientes:
  
A continuación empezará el proceso de instalación:
  

 Y por último, esperaremos a que finalice la instalación del sistema:
  

Una vez que hayamos descargado e instalado las herramientas de desarrollo, podremos compilar archivos fuente en el lenguaje C desde cualquier carpeta de nuestro sistema de archivos, simplemente accediendo a esa carpeta desde la terminal, y, asumiendo que nuestro archivo tenga el nombre mine. c, escribiendo el siguiente comando
gcc main.c
	Al estar basado en UNIX el sistema operativo de apple, de igual manera que ocurre en el sistema operativo linux, este comando generará un archivo llamado:
a.out
	Con lo cual, nuestro siguiente paso será ejecutar ese archivo binario ejecutable, invocando lo de la siguiente forma:
./a.out
	Tras lo cual se ejecutará nuestro programa.
Deberemos tener en cuenta que, aunque la extensión sea la misma que en el archivo generado en el sistema operativo linux, finalmente los ejecutables no son compatibles entre sí, ya que los sistemas operativos son diferentes 
3.6. Compilación de “Hola Mundo”
Una vez que hemos instalado las herramientas mínimas para poder realizar una compilación, es cuando podremos llamar al compilador gcc, introduciendo, como parámetro, el archivo que hemos guardado con nuestro primer programa, asumiendo que lo hayamos guardado en un archivo llamado 0001-holamundo.c
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0001-holamundo.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hola Mundo 
	La sintaxis, por tanto, en Windows es:
gcc.exe [tuarchivo.c]
	Y la sintaxis en Linux y en macOS es:
gcc [tuarchivo.c]
	________________






4. Arrancando el proyecto del curso
________________


4.1. Creación del proyecto del curso
A lo largo de esta obra vamos a ir mostrando, uno a uno, los bloques constructivos esenciales del lenguaje de programación C. Pero, además de los ejercicios individuales, vamos a ir creando, progresivamente, un proyecto en el cual iremos aplicando todos aquellos conocimientos que vayamos adquiriendo, con el objetivo de mostrar cómo empastan entre ellos los conocimientos individuales, en el momento de crear un programa completo.
Aplicando lo que hemos visto hasta el momento sobre el ejercicio del curso:
 📄main.c
	#include <stdio.h>

int main(int argc, char *argv[]) {
        printf("Programa agenda v1.0 \n");
        printf("Selecciona una opción \n");
        return 0;
}
	A continuación, una vez que ya hemos realizado el ejercicio teórico de esta unidad didáctica, es el momento de arrancar el ejercicio práctico que vamos a ir desarrollando poco a poco a lo largo de la publicación, hasta obtener un programa funcionalmente completo.
Para crear este programa, simplemente, lo único que tenemos que hacer, de la misma forma que anteriormente hemos creado un archivo con la extensión C, es crear un archivo llamado agenda.c, o main.c
Una vez que hayamos creado el archivo, lo abrimos con un editor de texto, introduciremos el siguiente contenido:
Al ejecutar el programa, cómo podremos comprobar, el programa básicamente devuelve los créditos iniciales, indicando que es el programa de agenda, que está en la versión 1.0, invitándonos a seleccionar una opción de un supuesto menú de opciones.
Evidentemente, en este momento, el menú no existe, ya que lo vamos a crear en las siguientes unidades didácticas.
Como veremos, por tanto, si bien a lo largo de las unidades didácticas se van a ir proponiendo una serie de ejercicios, y cada uno de los ejercicios se escribirá en un archivo diferente, como hemos comentado anteriormente en esta misma publicación, el ejercicio que ahora arrancamos es un ejercicio continuo que desarrollaremos a lo largo de todo el libro, para acabar generando un proyecto completo.
Es por esto que el código fuente que ahora acabamos de arrancar, será completado poco a poco, aplicando cada uno de los conocimientos teóricos que vayamos adquiriendo.
Por tanto, siempre estaremos trabajando sobre el archivo agenda. C, pero, sin embargo, recomiendo que, al aplicar cada uno de los contenidos teóricos de cada una de las unidades didácticas, no estemos trabajando sobre el mismo archivo de agenda, sino que creemos una copia de seguridad, una copia incremental sobre la que trabajar.
De hecho, mi recomendación es hacer exactamente lo mismo que puedes ver en los archivos descargados adjuntos de esta publicación, es que en cada una de las carpetas de cada una de las unidades didácticas, existe una versión incremental del proyecto.
Este, de hecho, es un consejo que no solo te ofrezco para el ejercicio de este curso, y no solo te ofrezco para trabajar en general con lenguajes de programación, sino que es algo que te recomiendo para cualquier proyecto informático que desarrolles, que es, en definitiva, el ir guardando copias periódicas de seguridad, tal que si en algún momento ocurre algún suceso, como que por ejemplo el código fuente se corrompa, aunque cometas algún error del cual no se paso salir, siempre tendrás, por lo menos, la versión anterior en funcionamiento, para en un caso extremo, poder volver atrás, pero en definitiva, poder volver a un paso del proyecto donde sabías que estaba funcionando.
Si ejecutamos el programa tal y como lo tenemos hasta el momento, obtendremos este resultado en la consola.
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0002-agenda.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Programa agenda v1.0 
Selecciona una opción 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	4.2. Reglas sintácticas
Es un buen momento, probablemente, de exponer una serie de reglas de sintaxis y de estilo que deberíamos aplicar no solo a los ejercicios individuales, sino especialmente al desarrollo del proyecto del curso.
4.2.1. Las terminaciones de línea
El programa informático, finalmente, está compuesto por una secuencia de instrucciones ejecutables.
Así que, es importante conocer cuáles son los Terminadores de instrucción, es decir, cómo se produce la separación entre una instrucción y otra, de manera que el programa sepa cuando tiene que acabar de ejecutar una instrucción, y cuando tiene que ejecutar la siguiente.
En muchos lenguajes de programación, el terminador entre instrucciones es el punto y coma.
En otros lenguajes de programación, el terminador es el carácter de retorno de carro, es decir, se asume que cada una de las líneas del programa puede contener únicamente una instrucción.
Hay lenguajes de programación que permiten diferentes caracteres determinación, tales como por ejemplo JavaScript, que permite terminar las instrucciones tanto con el punto y coma, como con un salto de línea
4.2.2. Las sangrías
Las sangrías, también llamadas indentaciones, son bloques de espacios que se suelen ubicar a la izquierda de las líneas que componen el código fuente del lenguaje en el que se está trabajando.
Dado que el código fuente de cualquier programa suele tener bloques de código anidados, es decir, bloques de código que dependen, que están subordinados a otros bloques, las sangrías son una manera desigual de poder saber que bloques dependen de otros.
Existen lenguajes, sin embargo, en los que estos sangrías no cumplen una misión puramente estética, sino que tienen un papel funcional, es decir, la sangría es la que realmente indica la hay lenguajes, sin embargo, en los que estos sangrías no cumplen una misión puramente estética, sino que tienen un papel funcional, es decir, la sangría es la que realmente indica la subordinación
En aquellos lenguajes en los que la sangría no tiene un papel funcional, sin embargo, se recomienda encarecidamente su uso, para que el código tenga un aspecto claro y entendible, aunque sea desde el . humano, y no desde la interpretación por parte de la máquina.
Es decir, no es una cuestión de rendimiento, sino de mantenibilidad del código, es decir, asegurar que el programa será fácilmente extendido por el mismo o por otros desarrolladores.
Evidentemente, en aquellos lenguajes en los que la sangría juega un papel funcional, tenemos que ubicar correctamente este recurso, ya que sino la propia ejecución del programa informático se verá comprometida.
4.2.3. Buenas prácticas
La mayoría de lenguajes de programación, por suerte, son bastante permisivos en cuanto a los estilos de programación.
Esto quiere decir que las reglas sintácticas del lenguaje de programación nos dejan bastante libertad para desarrollar nuestro propio estilo de programación.
Esto puede ser bueno, y también en ocasiones, puede ser negativo.
Si bien generalmente el hecho de que un lenguaje nos de libertad para programar a nuestro estilo puede ser considerado positivo, esta libertad también puede llevar al desarrollo de malos hábitos en la programación.
Estos malos hábitos en la programación, pueden tener consecuencias a medio y a largo plazo, como por ejemplo, el desarrollo de código no mantenible, o poco claro si vamos a compartir nuestro código con otros desarrolladores.
Es por esto que, siempre que podamos, deberemos adherirnos a una serie de reglas de estilo, de las cuales mencionamos unas pocas a continuación, iremos desarrollando otras tantas a la largo de los capítulos de esta publicación.
4.2.4. Uso de mayúsculas y minúsculas
Generalmente, las mayúsculas y minúsculas se usan de las siguiente manera:
* Las variables siempre irán escritas en minúsculas.
* Cuando el nombre de una variable contenga varias palabras, solo se pondrá en mayúscula la primera letra a partir de la segunda palabra, usando por tanto la nomenclatura camelCase.
* Los números de las constantes, por el contrario, irán siempre en mayúscula, todos los caracteres de la palabra.
* Los números de las funciones, al igual que las variables, irán siempre en minúscula salvo las primeras letras a partir de la segunda palabra
* Los números de las clases suelen ir en mayúscula con la primera letra.
Como veremos, estas buenas prácticas también son de utilidad en el momento en el que pensamos en cambiar de lenguaje, es decir, escribir con una serie de reglas que nos faciliten, en un momento dado, transicional de un lenguaje de programación a otro.
4.2.5. Claridad entre los nombres de las variables.
En principio, siempre intentaremos mantener las variables con una nomenclatura clara, tales que indiquen, de manera intuitiva, cuál es la finalidad de la información.
Con el objetivo de poder escribir código lo más rápido posible, buscaremos un compromiso al tener el número de la variable con el número de caracteres posibles pero a la vez, usando tantos caracteres o palabras como haga falta para retener el nombre de la variable.
Se entiende que buscar una, dos o tres palabras, será suficiente para definir correctamente la variable
El asunto de la simplicidad en la nomenclatura de las variables, de hecho, a veces es controvertido, ya que colisiona con algunos conceptos de seguridad informática.
Concretamente, hay un concepto llamado "seguridad a través de la oscuridad", que consiste en buscar los nombres de las variables para que, en el caso de que alguien robe el código fuente o haga ingeniería inversa, no tenga tan sencillo averiguar cuál es el nombre de las variables originales.
De todas formas, en esta publicación, se dará por supuesto que, en los casos en los que la claridad colisiones con la seguridad, se optará siempre por la claridad, aunque por supuesto, se intentará que el código desarrollado sea, cuando sea posible, tanto seguro como claro
________________
5. Comentarios
________________


5.1. Comentarios de una única línea
Los comentarios son mensajes o anotaciones que se introducen en cualquier parte del código fuente del programa que estamos desarrollando.
Estos mensajes, estos comentarios, son completamente ignorados por el intérprete, compilador, en lanzador, o en definitiva por cualquiera de las piezas que se encargan de interpretar el código de nuestro programa.
Por tanto, no tienen absolutamente ninguna regla sintáctica que seguir, más allá de aquella que define como empieza y acaba un comentario.
Fundamentalmente, se usan los dos comentarios para dos finalidades.
* La primera, la obvia, consiste en dejar mensajes en lenguaje humano aclarando el funcionamiento de una sección de código. Este mensaje puede ser dejado por un programador para asimismo, para cuando visualice su propio código fuente un tiempo después, para recordar la razón por la que había creado cada una de las secciones de código.
* También puede utilizarse para que un desarrollador dé instrucciones o pistas para que otros desarrolladores puedan comprender mejor su código.
Por regla general los comentarios del código constituyen una buena costumbre y una buena práctica, especialmente cuando estamos empezando nuestro aprendizaje en cualquier lenguaje de programación.
Desde el punto de vista de la mantenibilidad del código, también constituyen una herramienta muy importante para realizar una documentación de las tareas que cubre nuestro código fuente.
Sin embargo, como todo en la vida, no hay que pegar ni por defecto ni por exceso, y es por esto que se suele decir que, cuando un código tiene un exceso de comentarios, es decir, cuando el código es tan complejo que requiere muchos comentarios para que cualquier otro programador lo pueda comprender, se suele decir que entonces probablemente lo que hace falta es simplificar el código, y no sobre comentarlo.
La segunda utilidad de los comentarios, tan importante como la primera, es la de desactivar ciertas partes del código.
Durante el desarrollo de un programa, especialmente durante la fase de depuración, es decir, la fase en la que aparecen los errores de ejecución y tenemos que buscarlos y limpiarlos, es muy normal necesitar desactivar temporalmente ciertas partes del código, por varias razones, siendo la más común de ellas la propia búsqueda de errores por descarte.
Si abrazamos una porción del código con un comentario, el compilador cree que esa porción del código es un mensaje en formato humano, y por tanto, omite la ejecución de esa porción.
Una curiosidad con respecto a los comentarios de una única línea, es que no estuvieron soportados de forma oficial en C hasta C99 (aunque muchos compiladores daban soporte de forma no oficial)
Esto nos lleva a realizar un pequeño resumen de las versiones oficiales de C que podemos encontrar:
* Desarrollo inicial - 1969-1973
* C de Kernigan&Ritchie - 1978
* ANSI-C - 1990
* C99 - 1999
* C11 - 2011
* C18 - 2018
Los comentarios de una línea, por tanto, tienen el siguiente aspecto:
// Esto es un comentario de una sola línea
	Dentro del ejercicio del curso, quedarán de la siguiente forma:
#include <stdio.h>

int main(int argc, char *argv[]) {
   // Esto es un comentario de una sola línea
        printf("Hola Mundo \n");
        return 0;
}
	Si ejecutamos el programa anterior, podremos comprobar en la consola como el compilador omite completamente la línea correspondiente al comentario consistente en una doble barra, y saca únicamente por pantalla la línea correspondiente al comando printf.
Por lo tanto, el comentario que da , en el código fuente, únicamente para ser visualizado y utilizado por otro ser humano, y se omite en cualquier tipo de interpretación o compilación por parte de la máquina. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0003-comentarios.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hola Mundo 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	5.2. Comentarios de varias líneas
En la mayoría de lenguajes de programación hay dos tipos de comentarios, los de una única línea, y los de varias líneas
Éstos dos tipos de comentarios podrían quedar resumidos en este ejemplo a continuación:
#include <stdio.h>

int main(int argc, char *argv[]) {
   // Esto es un comentario de una sola línea
   /*
       Esto es un comentario
       de varias líneas
   */
        printf("Hola Mundo \n");
        return 0;
}
	En el lenguaje C originalmente, y más adelante en muchos otros lenguajes de programación que derivan de este lenguaje, podemos introducir comentarios en múltiples líneas arrancando el comentario con  la combinación de dos caracteres /*  y finalizando el comentario con la otra combinación de dos caracteres */
  /*
       Esto es un comentario
       de varias líneas
   */
	Todo aquel texto que se encuentre entre ese principio y ese final, será considerado como un comentario, y por lo tanto, como podemos ver en la ejecución en la terminal a continuación, será completamente omitido en la compilación del programa informático. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0003-comentarios.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hola Mundo 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	De la misma forma que se ha comentado en el apartado anterior, los comentarios originales en el lenguaje de programación C tienen este formato, incluso para aquellos comentarios que forman parte de una única línea.
Si bien hay soporte para comentarios de una única línea con el formato de la doble barra desde la versión 99 de c, es decir, prácticamente desde hace 25 años, deberemos tener en cuenta que, si se diera el caso mediante el cual tuviéramos que realizar una compilación para sistemas anteriores a esa versión, todos nuestros comentarios deberían tener el Formato de comentario multilínea, aunque estuvieran orientados a albergar un comentario de una única línea. 
5.3. Proyecto del curso
Aplicando lo que hemos aprendido sobre el ejercicio de la publicación:
A continuación, realizamos una copia de seguridad del estado anterior del proyecto, es decir, del proyecto agenda, en una nueva carpeta, para continuar dándole forma.
Recordamos que el único archivo que tiene, por el momento, nuestro proyecto, es un archivo llamado agenda. C.
Así que, a continuación, lo abrimos, introducimos el siguiente código:
📂proyectodelcurso/  📄main.c
	/* Programa agenda
por Jose Vicente Carratala */
#include <stdio.h>

int main(int argc, char *argv[]) {
   // Mensaje de bienvenida
        printf("Programa agenda v1.0 \n");
        printf("Selecciona una opción \n");
        return 0;
}
	Al ejecutarlo en la terminal o en la consola, podremos comprobar como los comentarios quedan omitidos durante el proceso de compilación y de ejecución, y en la consola únicamente vamos a ver cómo aparecen las líneas correspondientes a las operaciones de impresión por pantalla. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0004-agenda.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Programa agenda v1.0 
Selecciona una opción 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	

Por una parte, porque como podemos observar, hemos introducido un comentario de múltiples líneas, al principio del todo del código, a forma a modo de presentación, introduciendo el nombre del programa, el autor, lo que suele constituir una costumbre bastante extendida en la escritura de programas informáticos.
A continuación, dentro del método principal, hemos introducido un comentario de una única Lineal, indicando cuál es la función de las dos instrucciones a continuación.
Este comentario de una única línea será bastante frecuente a largo del desarrollo de los ejercicios parciales, y del ejercicio final, para comentar y explicar, el lenguaje humano cuál, cuál es la función de cada uno de los bloques de código que escribiremos en esta publicación.
________________
6. Errores
________________


Si vas a empezar a aprender a programar en cualquier lenguaje de programación, no solo el lenguaje que se presenta en esta publicación, debes empezar a considerar que el hecho de cometer errores, y tener que buscar y solucionar esos errores en el código, es una parte prácticamente inevitable del trabajo de desarrollo de aplicaciones informáticas
Esto es importante ya que , antes de empezar a aprender a programar, nadie tiene en cuenta este inevitable proceso, pero que, sin embargo, cualquier programador experimentado te dirá que forma parte del día a día de cualquier desarrollador de aplicaciones
La idea es que los lenguajes de programación finalmente convierten instrucciones al lenguaje de la máquina, lo cual quiere decir que los lenguajes de programación que aprendemos a utilizar no son más que abstracciones de alto nivel del lenguaje de bajo nivel que finalmente habrá la máquina con la que nos estamos comunicando
Y debemos entender que las máquinas tienen virtudes y tienen defectos. en cuanto a las virtudes podemos decir rápida y fácilmente que las máquinas son rápidas y precisas, pero en cuanto a los defectos, si las comparamos con los seres humanos, podemos decir también de una manera bastante evidente que las máquinas son poco adaptables a cualquier tarea que no sea aquella para la que han sido concebidas
Así que, en definitiva, las máquinas son muy poco tolerantes a fallos con respecto a la sintaxis en la que esperan recibir sus programas
En la comunicación humana, es decir, cuando estamos hablando con cualquier persona en la calle, podemos cometer diferentes errores de sintaxis o expresión y en definitiva, esto, en la gran mayoría de los casos, no supondrá un gran problema en la comunicación entre Dos personas
Aún cuando el error de expresión cometido suponga que nuestro interlocutor interlocutor no entienda el significado de lo que queremos transmitir, esto no detendrá la comunicación, sino que nuestro interlocutor simplemente nos preguntará acerca del significado de nuestras palabras, con lo cual tendremos la oportunidad de rectificar o explicarnos de diferente forma
Esto con las máquinas no ocurre
Sí una máquina espera recibir una instrucción de una forma determinada, únicamente aceptará la instrucción de esa forma, y no en cualquier otra forma que nosotros podamos enviar
Así que, si cometemos un error al escribir nuestro código , y esto evidentemente es muy frecuente, la máquina simplemente rechazar a la ejecución de la instrucción, y nos devolverá un mensaje de error
Y esto va a ocurrir miles y miles de veces durante nuestro proceso no solo de aprendizaje sino también de desarrollo de aplicaciones informáticas
Con esto, por tanto, lo que quiero decir, es que en programación de aplicaciones informáticas, el hecho de cometer errores y tener que solucionarlos no es algo propio únicamente de estudiantes noveles, sino que es algo totalmente común a cualquier nivel de experiencia en el campo
Evidentemente, y por supuesto, con los años, y con el aumento del nivel de experiencia, cada vez se cometen menos errores, y cuando se cometen, se pueden localizar y solucionar de una manera más rápida y más fácil. pero por muchos años que pasen, prácticamente cualquier programador te podrá confirmar que se siguen cometiendo errores
Así que, en definitiva, debemos adoptar una mentalidad tal que entendamos que no cometer errores no es un objetivo realista cuando empezamos a aprender a desarrollar programas
Nuestro objetivo, por contra, debe ser adoptar una actitud en la que demos por hecho los errores que vamos a cometer, y nos preparemos para, cuando estos errores sucedan, simplemente buscar el origen del error y solucionarlo
Este proceso al principio es complejo, porque consiste en admitir abiertamente que nos vamos a equivocar. y no solo una vez, ni dos, ni tres, sino debemos admitir que nos vamos a equivocar muchas veces, y que nuestro código va a fallar, y que el ordenador, finalmente, se va a negar a ejecutar nuestro programa
Desde un punto de vista psicológico esto es problemático porque en la gran mayoría de casos al ser humano no le gusta que le digan que está haciendo algo mal
Sin embargo, si superamos ese primer momento inicial de frustración por el qué pasa cualquier aprendiz de programador veremos que, simplemente, llega un momento en el que aceptamos esa búsqueda y solucionado de errores, una parte más del proceso natural de desarrollar aplicaciones informáticas, y en definitiva, adoptaremos una actitud y una mentalidad abierta y preparada para desarrollar cualquier tipo de programa informático 
6.1. Diferentes tipos de errores 
6.1.1. Introducción a los errores 
Resulta difícil realizar una categorización que resulte fiable para cualquier escenario en cuanto a los diferentes tipos de errores que podemos obtener al realizar programas informáticos, ya que estos pueden ser de muchas y muy variadas naturalezas.
Sin embargo, una sencilla clasificación para poder comprender rápida y fácilmente los errores que vamos a encontrar durante la realización de nuestros programas, consiste en dividirlos en dos grandes grupos, que son:
*  errores sintácticos
*  errores lógicos
A continuación vamos a realizar una explicación, y donde sea posible, una demostración de los dos grandes grupos de errores, para poder entender cuál es la diferencia entre ambos tipos. 
6.1.2. Errores sintácticos 
Los errores sintácticos son aquellos mediante los cuales cometemos algún error en la propia sintaxis del lenguaje de programación.
El ejercicio que se muestra a continuación, representa uno de los errores más comunes que podemos cometer cuando empezamos a programar, qué consiste en olvidar cerrar cada una de las instrucciones mediante un . y coma.
En el siguiente ejercicio tenemos que, en una de las líneas, completamente la línea en la que se realiza una operación de impresión por pantalla, falta el carácter del punto y coma, al final de la línea.
printf("Hola Mundo \n")
	Muchas veces damos por hecho que simplemente por bajar a la siguiente línea, el programa entiende que nos encontramos en otra instrucción o en otro comando, pero sin embargo debemos recordar que en el lenguaje de programación C, el único carácter que cierra realmente una instrucción para diferenciarla de la siguiente instrucción, es el . y coma. 
#include <stdio.h>

int main(int argc, char *argv[]) {
   // Esto es un comentario de una sola línea
   
   /*
       Esto es un comentario
       de varias líneas
   */
        printf("Hola Mundo \n")
        return 0;
}
	Si intentamos compilar este programa, veremos como la compilación es fallida, y el compilador nos da un mensaje de error, que además nos resulta tremendamente útil para tener una cierta idea de cuál es el error que hemos cometido, y cómo solucionarlo.
El compilador no nos va a dar siempre mensajes tan claros como el que se muestra en este ejemplo, pero precisamente porque el hecho de olvidar poner puntos y , como terminadores de instrucciones es uno de los errores más comunes, el compilador detecta correctamente este error, y no saca una información de ayuda bastante completa y bastante precisa que nos permitirá corregir lo de forma sencilla. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0005-errores.c 
0005-errores.c:10:25: error: expected ';' after expression
       printf("Hola Mundo \n")
                              ^
                              ;
1 error generated.
MacBook-Pro-de-Jose:cursodec josevicente$
	No siempre el compilador nos dará información tan precisa, porque el propio compilador no puede tener un listado de todos los errores que podemos cometer a lo largo de la escritura de nuestros programas.
A continuación, en base a la experiencia como docente durante años, te ofrezco un listado de los errores más comunes que suelen cometer mis alumnos, y por lo tanto, cuando tu programa arroje un error de compilación y no sepas exactamente cuál es el . del programa en el cual está dando error, podrás realizar una comprobación previa en base al listado que te ofrezco a continuación:
* Errores debido a no haber finalizado las instrucciones con . y coma
* Errores de encadenamiento, al faltar introducir el carácter +  cuando venga G diferentes cadenas alfanuméricas, entre ellas o con variables.
* Ligeros errores en la sintaxis de los identificadores, por ejemplo en variables o arreglos, o en las instrucciones nativas del lenguaje de programación
6.1.3. Errores lógicos 
Los errores lógicos son, probablemente, los más difíciles de ilustrar en el . en el que nos encontramos dentro de esta publicación, ya que, hasta el momento, no hemos desarrollado realmente lógica de flujo de datos dentro de nuestra aplicación informática sino que, por el momento, en estos pasos iniciales en los cuales nos encontramos, únicamente estamos sacando información por pantalla. 
Por el momento, se muestra un ejemplo que ilustra un caso que encontraremos en un capítulo más adelante de este libro, correspondiente al uso de funciones dentro del lenguaje de programación, en el cual podemos encontrar el siguiente caso: 
En este ejercicio, declaramos una función externa a la función principal, cuya misión es sacar por pantalla una cadena de caracteres que se encarga de realizar un saludo.
Sin embargo, más adelante, en la función principal, podemos observar como he dejado, a propósito, una línea completamente en blanco, en la que he olvidado llamar a la función de saludo.
Como consecuencia, podemos comprobar como tengo correctamente declarada una función que se encarga de saludar al usuario, pero he olvidado usar esa función, es decir, he olvidado llamar a esa función dentro de la función principal. 
#include <stdio.h>
void saluda(){
   printf("Hola, Jose Vicente \n");
}
int main(int argc, char *argv[]) {
   
        return 0;
}
	

Cuando ejecutamos el programa, podemos comprobar que ni en la compilación ni en la ejecución obtenemos ningún error en la terminal o en la consola, porque técnicamente, desde un punto de vista sintáctico, no hemos cometido ningún tipo de error.
El compilador es consciente de que hemos declarado una función que realmente no estamos utilizando en ningún momento dentro del método principal, pero el compilador no tiene la inteligencia suficiente como para saber si esa falta de llamada a la función ha sido accidental, o si por el contrario corresponde a nuestra voluntad. 
Por lo tanto, cuando ejecutamos el programa podemos comprobar como el programa no realiza ningún saludo en ningún momento, y deberemos ser nosotros los que repasemos el programa línea a línea, para comprobar en qué punto de la ejecución se encuentra el error. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0054-funcionmain.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
	________________




7. Operaciones de impresión de datos en pantalla
________________


7.1. ¿Que son?
Un lenguaje de programación no tiene porque estar mostrando continuamente información en pantalla.
Puede tomar datos de entrada, y puede estar continuamente operando con esos datos de entrada de manera interna, sin mostrar, hasta el final, o quizás a veces nunca, nada de información al ser humano.
Sin embargo, cuando estamos aprendiendo a programar, es altamente útil contar con algún tipo de salida por pantalla, para, de alguna manera, poder comprobar que el código que estamos desarrollando cumple las funciones que inicialmente estaban previstas.
es por esto que, en el aprendizaje de cualquier lenguaje de programación, es altamente útil que, a lo largo de los primeros pasos de aprendizaje, se aprende algún tipo de instrucción que nos permita realizar una salida de información por pantalla, ya sea a través de una consola, o bien a través de una interfaz de usuario más elaborada, como por ejemplo, una aplicación en ventanas
#include <stdio.h>

int main(int argc, char *argv[]) {
        printf("Esto es un mensaje \n");
        printf("Esto es otro mensaje \n");
        return 0;
}
	Al ejecutar este programa en la terminal o en la consola, vamos a poder comprobar cómo aparecen las dos líneas introducidas mediante las dos instrucciones de impresión por pantalla. 
Debemos recordar que las instrucciones de impresión por pantalla por defecto, en el lenguaje de programación C, no incluyen un retorno de carro al final de cada una de las instrucciones, y por lo tanto debemos introducirlo nosotros de forma manual añadiendo la pareja de caracteres \n  al final de cada una de las líneas. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0006-impresion.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Esto es un mensaje 
Esto es otro mensaje 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Las operaciones de impresión en pantalla, por el momento, son nuestra herramienta para crear, de alguna manera, interfaces de usuario.
De esta forma, en definitiva, vamos a estar trabajando con esta instrucción, para que el programa se comunique con nosotros.
Durante una buena parte de esta publicación, por lo tanto, estaremos trabajando desde la terminal, es decir, tanto usaremos la terminal para introducir información, cómo será la terminal la que nos devuelva información.
De esta forma, debemos adaptarnos a ciertas reglas de los terminales tanto de Windows, como de Linux, como de Mac.
Es por esto que, como habremos observado en el código, muy frecuentemente encontraremos el carácter de \n.
Este carácter, en cualquier terminal, no sirve para invocar el retorno de carro, o lo que es lo mismo, la creación de una nueva línea, es decir, que el programa finalice la línea actual, y coloque el cursor en una nueva línea a continuación, debajo de la línea antigua.
Sin embargo, una vez más, debemos recordar que el motivo de este carácter es porque estamos trabajando en la terminal.
Por ejemplo, otro uso de fe es generar archivos cgi para ser ejecutados en un servidor web, que en definitiva, acaba transformando la información en el código html.
Es decir, en ese caso, en el caso de la creación de archivos cgi con el lenguaje sí, finalmente, el contenido no se muestra en la consola sino que se muestra en un navegador web, con las reglas del lenguaje html.
De esta forma, cuando esto ocurre, el carácter de retorno de carro no es \n,  sino que es el propio de ese lenguaje de marcaje, que es <br>
7.2. Ejercicio del curso
Aplicando lo que hemos aprendido en el ejercicio de la publicación:
A continuación, abrimos el programa con el que hemos estado trabajando en las dos lecciones anteriores, introducimos una serie de líneas, que nos ayudarán a formatear un menú de inicio.
Es decir, una vez que hemos presentado el programa, la versión, y le hemos indicado al usuario que debe seleccionar una opción, introducimos una serie de líneas más, para especificar cuáles son estas opciones disponibles en el programa.
Deberíamos notar la presencia de los caracteres contra barrote, y \n.
El carácter \n, como hemos comentado anteriormente, nos sirve para saltar una nueva línea.
El carácter \t, actúa de manera similar, con la diferencia de que, en lugar de saltar a una nueva línea, realiza un salto de tabulador.
En definitiva, nos permite realizar una sangría, no ya en el código que estamos escribiendo, sino en el texto que escribe el programa en la consola en el momento de ejecutarse.
Podremos observar, en la última de las operaciones de impresión, se nos ofrece escoger una opción.
Evidentemente, de momento paramos el desarrollo del ejercicio del curso aquí, ya que todavía no sabemos cómo hacer para que el usuario introduzca una opción, y el programa la reconozca. Evidentemente esto se va a desarrollar en las siguientes unidades didácticas de esta publicación.
📂proyectodelcurso/   📄main.c
	/* Programa agenda
por Jose Vicente Carratala */
#include <stdio.h>

int main(int argc, char *argv[]) {
   // Mensaje de bienvenida
        printf("Programa agenda v1.0 \n");
        printf("Selecciona una opción \n");
        printf("\t 1 - Listado de registros \n");
        printf("\t 2 - Introducir un registro \n");
        printf("\t 3 - Eliminar un registro \n");
        printf("\t 4 - Buscar un registro \n");
        printf("\t 5 - Actualizar un registro \n");
        printf("Tu opcion: ");
        return 0;
}
	Al ejecutar el código, podremos comprobar como en la terminal o en la consola aparecen correctamente representados todos los textos, así como los caracteres de escape, que nos permiten ejecutar un retorno de carro cuándo es conveniente, o nos permiten insertar un tabulador, especialmente al principio de cada una de las opciones, para poder representar las líneas correspondientes a dichas opciones de una forma más limpia y más ordenada cuando ejecutamos el programa. 
En principio puede parecer un error el hecho de que, aparentemente, hemos olvidado añadir un carácter de retorno de carro en la última línea de impresión, pero no es realmente un error, ya que estamos preparando el ejercicio para la siguiente parte, en la cual tomaremos la entrada del usuario, es decir, el usuario deberá indicar cuál de las opciones escoge para empezar. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0007-menu.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Programa agenda v1.0 
Selecciona una opción 
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
Tu opcion: MacBook-Pro-de-Jose:cursodec josevicente$ 
	



________________




8. Variables
________________


8.1. ¿Qué son las variables?
Como vamos a poder ver durante el desarrollo de los ejercicios de este libro, en el lenguaje de programación C, al igual que ocurre en cualquier otro lenguaje de programación, trabajamos con una serie de datos, en base a los cuales realizamos una serie de operaciones, a conveniencia de aquello que quiera obtener el usuario final. 
De esta forma, es importante contar con un mecanismo, o si es posible varios, para poder guardar información, es decir, para poder guardar los datos con los cuales va a trabajar el programa, y poder realizar operaciones con ellos.
Si bien en cualquier lenguaje de programación, y en este caso el lenguaje fe no es una instrucción, existen multitud de estructuras de datos para poder permitirnos almacenar la información de múltiples formas diferentes, el contenedor de datos más básico en cualquier lenguaje de programación es el que presentamos dentro de este capítulo, qué corresponde al uso de variables.
Las variables, por tanto, son contenedores muy básicos de información que nos permiten guardar piezas de datos, con la característica de que, una vez que guardemos una información en una variable, tal y como su propio nombre indica, dicha información podrá ir cambiando durante la ejecución del programa, a nuestra conveniencia. 
8.2. Tipos de datos
Los tipos de contenedores de datos para las variables varían bastante entre un lenguaje de programación y otro.
Sin embargo, a continuación, voy a indicar los grandes tipos de variables que encontramos a lo largo de los lenguajes de programación más comunes hoy en día.
8.3. Variables de tipo numérico
Estas variables guardan números en multitud de formatos.
En primer lugar tenemos las variables de tipo entero, que guardan números decimales.
int variable = 5;
	El código del ejercicio tendrá el siguiente aspecto
#include <stdio.h>

int main(int argc, char *argv[]) {
   int variable = 5;
        printf("La variable vale: %i \n",variable);
        return 0;
}
	En todo momento hasta este punto, hemos estado trabajando con la instrucción llamada printf
Esta instrucción , que corresponde a la abreviatura de print format,  nos permite realizar impresiones en pantalla respetando el formato de los datos originales.
Por lo tanto, dentro de la sintaxis de esta Instrucción, encontramos que podemos encadenar la parte de cadena alfanumérica, con el uso de diferentes variables, utilizando el carácter de la , como separador. 
Dentro de la cadena alfanumérica deberemos introducir un conjunto especial de caracteres para indicar el punto en el cual queremos insertar la variable que estamos utilizando dentro de esa cadena.
Además, deberemos tener en cuenta que  la pareja de caracteres a insertar deberá estar en función del tipo de dato que estamos insertando. De esta forma para este ejercicio, la pareja de caracteres para insertar una variable de tipo número entero es %i 
printf("La variable vale: %i \n",variable);
	Este será el resultado de ejecutar el código
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0008-variables.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
La variable vale: 5 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	A continuación tenemos las variables de tipo flotante, que son capaces no solo de guardar números enteros, positivos, sino que también son capaces de guardar fracciones decimales de los números. 
float variableConDecimales = 0.5;
	Son capaces de guardar decimales, para aquellos casos en los que necesitemos aumentar la precisión en el cálculo. en el siguiente ejemplo, mostrado a continuación, podemos observar como se declara tanto una variable de tipo entero, como una variable de tipo flotante, es decir, con la posibilidad de guardar decimales 
#include <stdio.h>

int main(int argc, char *argv[]) {
   int variable = 5;
        printf("La variable vale: %i \n",variable);
        float variableConDecimales = 0.5;
        printf("La variable vale: %f \n",variableConDecimales);
        return 0;
}
	

En este caso observaremos, al ejecutar este programa en la terminal o en la consola, qué repetimos el esquema que hemos empezado a desarrollar en el ejercicio anterior , pero en este caso, al imprimir con formato la cadena que nos permite obtener la variable en pantalla, la pareja de caracteres que representa el número flotante ha cambiado con respecto a la pareja de caracteres que representa a un número entero.
printf("La variable vale: %f \n",variableConDecimales);
	 de esta forma y por lo tanto:
* Usaremos %i  para representar números enteros
* Usaremos %f  para representar números con decimales 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0009-variabledecimales.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
La variable vale: 5 
La variable vale: 0.500000 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	8.4. Texto
Existen varias formas de guardar cadenas de texto dentro de nuestros programas desarrollados en C
Una de ellas es mediante el tipo de dato primitivo char, que, como su nombre indica, es capaz de guardar un carácter
Podríamos considerar, por tanto, que una palabra o incluso una frase o un texto no es más que un conjunto de caracteres dispuestos uno detrás de otro
De esta forma, aunque la cuestión de las matrices y los arreglos será discutida más adelante, en este caso, estamos creando una variable a la que, a continuación, e introducimos un corchete de apertura y un corchete de cierre
char variableTexto[] = "Jose Vicente";
	Estos dos corchetes indican que esa variable no solo contiene una unidad de ese tipo de datos, en este caso un carácter, sino que contiene un conjunto de ese tipo de datos, es decir, en este caso concreto contiene un conjunto de caracteres, o lo que es lo mismo, una palabra, o un texto 
#include <stdio.h>

int main(int argc, char *argv[]) {
   int variable = 5;
        printf("La variable vale: %i \n",variable);
        float variableConDecimales = 0.5;
        printf("La variable vale: %f \n",variableConDecimales);
        char variableTexto[] = "Jose Vicente";
        printf("La variable vale: %s",variableTexto);
        return 0;
}
	Al ejecutar el programa comprobamos como, al declarar una cadena de caracteres, lo hacemos declarando un arreglo de caracteres individuales, dentro de los cuales podemos introducir tantos caracteres seguidos como necesitemos.
Al imprimir la cadena con formato, seguiremos el mismo esquema con el cual hemos estado trabajando en los ejemplos anteriores, para ampliar el modelo que teníamos hasta ahora, teniendo en cuenta lo siguiente 
printf("La variable vale: %s",variableTexto);
	* Usaremos %i  para representar números enteros
* Usaremos %f  para representar números con decimales 
* Usaremos %s  para representar cadenas de caracteres alfanuméricos 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0010-variabledecimales2.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
La variable vale: 5 
La variable vale: 0.500000 
	8.5. Reglas de declaración de Identificadores de variables
Debemos tener en cuenta que existen una serie de reglas para declarar correctamente variables.
Estas reglas pueden variar a lo largo de los lenguajes de programación, y es por esto que yo suelo recomendar una serie de pautas, comunes entre los diferentes lenguajes de programación, para asegurar que, más adelante, vamos a poder saltar de un lenguaje de programación a otro teniendo que reaprender el mínimo número de cosas posibles.
Las variables pueden contener números, pero no deben empezar con números.
De esta forma, esto estaría perfectamente aceptado:
#include <stdio.h>

int main(int argc, char *argv[]) {
   int variable2 = 5;
        return 0;
}
	Veremos como la compilación de ese código no proporciona ningún error en la terminal o en la consola, tanto en el proceso de compilación como en el proceso de ejecución 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0011-declaracion.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
	Esto también estaría aceptado
#include <stdio.h>

int main(int argc, char *argv[]) {
   int vari3able = 5;
        return 0;
}
	Igualmente como en el caso anterior, comprobaremos como al compilar y ejecutar no tenemos ningún error. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0012-declaracion2.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out
	Pero esto no sería aceptable, ya que quedaría error en la mayoría de programas.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int 1variable = 5;
        return 0;
}
	Al intentar compilar esta aplicación, encontraremos como dentro de las reglas de creación de identificadores, ya sea variables en este caso, u otras estructuras de datos más adelante, no es posible comenzar la declaración de un identificador con un tipo numérico, es decir, con un número, y por lo tanto el compilador da error indicando el . del identificador, en este caso el primer carácter, dónde se encuentra el error. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0013-errordeclaracion.c 
0013-errordeclaracion.c:4:9: error: expected identifier or '('
   int 1variable = 5;
       ^
1 error generated.
	La mayoría de lenguajes de programación no aceptan el uso de espacios a la hora de declarar variables. Los espacios serán reemplazados por guiones bajos.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int una_variable = 5;
        return 0;
}
	En el caso, por tanto, de necesitar crear un identificador que contenga varias palabras, podremos comprobar como se recomienda perfectamente utilizar los guiones bajos como separador visual de palabras. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0014-guiones.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out
	Existe otro tipo de nomenclatura para crear identificadores, llamada camelCase, o lo que es lo mismo, como si hubiéramos metido un camello dentro de una maleta, que corresponde en encadenar directamente las palabras que contiene el identificador, y únicamente a partir de la segunda palabra, poner la primera letra de cada palabra en mayúsculas. 
El ejercicio quedaría de la siguiente forma 
#include <stdio.h>

int main(int argc, char *argv[]) {
   int unaVariable = 5;
        return 0;
}
	Podremos comprobar cómo compila perfectamente, por lo cual esta forma de declarar identificadores es perfectamente válida. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0015-camelcase.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out
	Aunque podemos utilizar perfectamente está nomenclatura, también es cierto que en cuanto a conjuntos de buenas prácticas, en principio se suele utilizar la nomenclatura correspondiente a separar varias palabras con guiones bajos para declarar variables, y la nomenclatura camelCase en el caso de crear funciones.
Por lo tanto, siempre que nos sea posible, en el caso de que nuestras variables contengan Marías palabras, las podremos separar con estos diversos métodos, pero le daremos preferencia al método de separar las palabras con guiones bajos. 
8.6. Soporte para Unicode
La gran mayoría de lenguajes modernos tienen soporte para Unicode, permitiéndonos usar caracteres como vocales con acento, la letra ñ, o la ç para el nombre de las variables.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int escaño = 5;
        return 0;
}
	Al compilar este código podremos comprobar cómo podemos declarar identificadores utilizando caracteres tales como por ejemplo la ñ o vocales con acento, y el compilador funcionará perfectamente bien. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0016-utf8.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out
	Mi recomendación, en la medida de lo posible, es no usar estos caracteres, por una cuestión de retrocompatibilidad, y compatibilidad entre lenguajes de programación.
Sin embargo, curiosamente, también recomiendo poner nombres de variables, funciones, clases, y otras estructuras en castellano y no en inglés.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int edad = 5;
   int age = 5;
        return 0;
}
	En este ejemplo vemos como declaramos dos variables, que representan el mismo concepto, estando el identificador de una de ellas en español, y el otro identificador en inglés. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0017-idioma.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out
	Los lenguajes de programación, todos ellos, tienen palabras reservadas. Las palabras reservadas no pueden ser usadas por el desarrollador, para crear identificadores libres.
Cuando estamos aprendiendo a programar, una de las dificultades más costosas de superar, consiste en saber, en un determinado código, cuáles son las palabras que nosotros, pero como programadores, podemos cambiar, y cuáles son las palabras reservadas por el lenguaje de programación.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int auto = 5;
        return 0;
}
	Al compilar este programa, el proceso de compilación arroja un error fatal que no permite continuar, que además, en este caso, es difícil de depurar, ya que el mensaje que sale por pantalla indica que se esperaba un identificador, cuando nosotros, aparentemente, hemos introducido un identificador de forma correcta.
El problema, en este caso, consiste en que la palabra que hemos utilizado para el identificador es una palabra reservada del lenguaje de programación, y por tanto no podemos utilizarla libremente para descargar cualquier otro tipo de variable. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0018-reservada.c 
0018-reservada.c:4:14: error: expected identifier or '('
   int auto = 5;
            ^
1 error generated.
	Dado que prácticamente todos los lenguajes de programación están escritos en inglés, en nuestro caso, hablar en español puede suponer una ventaja, ya que nos permite nombrar a nuestras estructuras en nuestro idioma, y de esa forma, podemos diferenciarlas perfectamente, y sabemos que, salvo en mi caso es concretos como el uso de la palabra " final ", es decir, palabras que existen en los dos idiomas, salvo en esos casos concretos, las probabilidades de colisión disminuyen, y el entendimiento del código fuente mejora.
Evidentemente, es de Consejos solo es aplicable para desarrolladores o equipos de desarrollo formados únicamente por personas españolas o por personas para las que el español sea su lenguaje natural.
En el caso de que el equipo de trabajo esté compuesto por personas de otras nacionalidades, en ese caso, por claridad y en pro de la comunicación, será recomendable usar nomenclatura inglesa para todas las estructuras que puede elegir el usuario
8.7. Listado de palabras reservadas de C
Estas son las 32 palabras reservadas en C que no debemos usar como nombres de variables o estructuras:
auto, break, case, char, const, continue, default, do, int, long, register, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while, double, else, enum, extern, float, for, goto, if
8.8. Aplicación sobre el ejercicio El curso 
A continuación, aplicamos lo que hemos aprendido en la presente unidad didáctica, hasta el momento, al ejercicio que estamos desarrollando en el curso
Si anteriormente hemos definido un menú en el que el usuario podrá seleccionar una serie de opciones, preparamos un carácter para poder recibir esas opciones
Debemos tener en cuenta que, ahora mismo, hemos aprendido a crear variables, y a preparar las para contener datos, pero todavía no hemos aprendido a pedirle una entrada de datos al usuario humano, y poder guardar esos datos en una variable. evidentemente, esto no aprenderemos en las siguientes unidades didácticas
Sin embargo, adelantamos el hecho de que, cuando le pedimos al usuario una entrada de datos, por defecto esta entrada se efectúa en formato de carácter, o cadena de caracteres
Es por esto que el lector se podría preguntar cuál es el motivo de estar declarando una opción como un tipo de carácter, cuando las opciones consisten en indicar un número desde el 1 hasta el 5. en principio, podríamos pensar que el tipo de variable más correcto sería el de número entero, ya que coincide con el concepto de números enteros desde el 1 hasta el 5 
Sin embargo, debido a que la entrada de datos se produce por defecto en formato de carácter, es por eso que estoy reservando una variable específica con ese tipo de datos, para que no haya discordancia entre los datos recibidos, y el tipo de dato de la variable que finalmente lo va a guardar, un problema que, por cierto, es muy característico de los programas informáticos, y que más adelante, hacia el final de la publicación, veremos cómo tratar 
/* Programa agenda
por Jose Vicente Carratala */
#include <stdio.h>

int main(int argc, char *argv[]) {
   // Mensaje de bienvenida
        printf("Programa agenda v1.0 \n");
        printf("Selecciona una opción \n");
        printf("\t 1 - Listado de registros \n");
        printf("\t 2 - Introducir un registro \n");
        printf("\t 3 - Eliminar un registro \n");
        printf("\t 4 - Buscar un registro \n");
        printf("\t 5 - Actualizar un registro \n");
        printf("Tu opcion: ");
        char opcion;
        return 0;
}
	En el ejercicio que estamos desarrollando a lo largo del libro, al menos hasta el punto en el que nos encontramos actualmente, al usuario se le ofrecen una serie de opciones, al menos estéticamente en pantalla, y a continuación el usuario deberá elegir una de estas opciones.
Por lo cual, podemos comprobar cómo hemos introducido  una variable de tipo carácter que almacenará, más adelante , la elección del usuario, y en base la cual podremos continuar operando dentro de nuestro programa. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0019-agenda.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Programa agenda v1.0 
Selecciona una opción 
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
Tu opcion:
	8.9. Constantes
Las variables ocupan un cierto espacio en la memoria, y no solo eso, sino que además el uso de espacio no es particularmente eficiente desde el . de vista en que se está reservando un espacio que se supone que está abierto a cambios puntos
Existen ocasiones, sin embargo, en las que, cuando declaramos una variable, sabemos que su valor, pese a su nombre, no va a variar a lo largo del programa.
Un ejemplo clásico fácilmente entendible es el valor del número pi.
Cuando tenemos este tipo de recursos, usamos, siempre que el lenguaje de programación tenga disponible, el concepto de constante.
Una constante básicamente es como una variable, pero no varía su contenido a lo largo de la ejecución del programa.
Esto puede parecer una desventaja con respecto a usar variables, pero sin embargo, también cabe decir que el uso de constantes optimiza el uso de memoria por parte del programa, y por tanto, el rendimiento en su ejecución.
Así que, de esta manera, será recomendable que usemos constantes siempre que podamos, y siempre que estemos trabajando con un programa donde el rendimiento sea un factor clave.
#include <stdio.h>
#define PI 3.1416

int main(int argc, char *argv[]) {
   const float velocidadSonido = 343.2;
   printf("El valor de pi es: %f \n",PI);
   printf("La velocidad del sonido es:  %f \n",velocidadSonido);
        return 0;
}
	Al ejecutar el programa, por lo tanto, podremos comprobar cómo creamos una variable de tipo flotante que tiene el modificador de constante , y a continuación la sacamos por pantalla.
Otra de las ventajas que siempre se han asociado al uso de constantes en aquellos casos donde realmente esté justificado, consiste en prevenir algunos problemas relacionados con errores lógicos durante la ejecución de un programa informático.
No es muy frecuente, pero en ocasiones se puede dar el caso de que parte de los errores lógicos que podemos obtener durante la ejecución de un programa pueden venir por cambios no previstos de los valores de los identificadores, ya sean variables, o constantes.
Si un almacenamiento de datos es una variable, y le cambiamos su valor, aunque no esté previsto que si lo cambiamos, el programa no arroja ningún tipo de error.
Sin embargo, si  de un elemento sabemos que su valor no debería cambiar, en ese caso podemos declararlo como constante, con la premisa de que , si  en algún momento del programa alguien intenta realizar un cambio sobre ese valor, dará un error de compilación, y podremos localizar de una forma mucho más sencilla dónde se encuentra el error. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0020-constantes.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El valor de pi es: 3.141600 
La velocidad del sonido es:  343.200012 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	8.10. Ejercicio del curso
A continuación, he creado una nueva copia de seguridad del proyecto del curso, y, sobre el único archivo que ahora mismo compone el proyecto, que es el agenda, se ha añadido el siguiente código:
📂proyectodelcurso/   📄main.c
	/* Programa agenda
por Jose Vicente Carratala */
#include <stdio.h>
#define NOMBREPROGRAMA "Programa agenda"
#define VERSION "1.0"
#define AUTOR "Jose Vicente Carratala"

int main(int argc, char *argv[]) {
   // Mensaje de bienvenida
        printf("%s v%s \n",NOMBREPROGRAMA,VERSION);
        printf("%s \n",AUTOR);
        printf("\t 1 - Listado de registros \n");
        printf("\t 2 - Introducir un registro \n");
        printf("\t 3 - Eliminar un registro \n");
        printf("\t 4 - Buscar un registro \n");
        printf("\t 5 - Actualizar un registro \n");
        printf("Tu opcion: ");
        char opcion;
        return 0;
}
	

Como podemos comprobar, he definido tres constantes en la zona del preprocesador, indicando tanto el nombre del programa, como la versión, como el autor.
#define NOMBREPROGRAMA "Programa agenda"
#define VERSION "1.0"
#define AUTOR "Jose Vicente Carratala"
	Lo primero que debemos notar, es que, por el estilo, los números de las variables se describen completamente en mayúsculas, para diferenciarlas de las variables que más adelante definiremos.
Recordemos, que, una vez más, las constantes podrían declararse siguiendo la nomenclatura camelcase, O todo en minúsculas, pero aceptamos la regla estilística para que nuestro código esté en sintonía con las reglas que están usando el resto de programadores.
En cuanto al uso de constantes, evidentemente se debe a que, una vez que el Programa se ha empezado a ejecutar, no esperamos que cambie el nombre del programa, la versión, o el autor.
De esta forma, es por lo que, pudiendo haberlas declarado como variables, las hemos declarado como constantes, para hacer un uso más eficiente de la memoria, ya que recordamos que las constantes son más fáciles de albergar que las variables.
Por otra parte, al final del programa, observamos como el creado una variable de tipo carácter para almacenar la opción que, más adelante, el usuario elegirá.
char opcion;
	Evidentemente, esta opción se declara como variable y no como constante, ya que a lo largo de la ejecución del programa, por supuesto será normal que la opción que vaya eligiendo el usuario final del programa, vaya variando.
Es decir, eso talmente normal que el usuario, por ejemplo, empiece obteniendo un listado de registros, luego eligen introducir un registro, y más adelante, quién sabe, podrá eliminar, buscar, o actualizar, en definitiva, ir a eligiendo una opción diferente en cada una de las situaciones dentro de la misma ejecución, y es por esto que la opción nunca debería ser una constante, ya que se espera que vaya a variar.Al ejecutar este código podremos comprobar como las instrucciones proporcionadas en el preprocesador que interpretan como constantes, lo cual nos permite luego utilizarlas dentro de la función principal, por ejemplo para introducir el nombre del programa y la versión.
La idea es que habrá datos que puedan cambiar dentro del programa, tales como por ejemplo la opción que ha elegido el usuario, pero habrá datos que no es esperable que cambien, tales como por ejemplo el nombre del propio programa.
En esos casos, por ejemplo, al igual que en muchos otros casos en muchos escenarios, es donde es perfectamente posible y está totalmente justificado utilizar contenedores de datos de tipo constante. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0021-agendaconstantes.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Programa agenda v1.0 
Jose Vicente Carratala 
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
Tu opcion:
	

________________


9. Entrada de información en un programa
________________


9.1. Atrapando caracteres con getchar
Anteriormente hemos aprendido cómo extraer información del programa, y mostrarla al ser humano, de momento en la consola, y mediante la instrucción printf.
También hemos aprendido anteriormente que un programa no es más que una serie de operaciones realizadas sobre unos datos de partida, y que ofrecen un resultado en base a cálculos realizados sobre esos datos.
Así que sabemos cómo extraer datos en la pantalla, y pronto aprenderemos cómo realizar cálculos dentro del propio programa. Pero, ¿cómo podemos permitir al usuario introducir información?
Existen varias formas de permitir que un usuario introduzca información dentro de una aplicación informática.
En el caso del lenguaje que nos ocupa en esta publicación, la instrucción más frecuente para permitir esta entrada, forma parte de la misma librería de entrada y de salida que nos permite escribir texto en la consola.
char seleccion = getchar()
	Usaremos las siguiente instrucción, dentro de este programa de ejemplo, de forma de forma que:
#include <stdio.h>

int main(int argc, char *argv[]) {
   printf("Introduce una tecla: ");
   char seleccion = getchar();
   printf("El caracter que has seleccionado es: %c \n",seleccion);
        return 0;
}
	Al ejecutar el código anterior en la consola, vamos a poder comprobar cómo seremos perfectamente capaces de atrapar la entrada por parte del usuario, introducirla en una variable, y por último lanzarla en una operación de impresión por pantalla. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0022-entrada.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Introduce una tecla: a
El caracter que has seleccionado es: a 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Cuando ejecutamos el programa, comprobamos como la ejecución queda detenida en ese . concreto del programa, esperando a que el usuario introduzca una letra, una palabra, o una línea dentro de la consola.
Debemos tener en cuenta que, según la tipificación de los datos que hemos introducido, ahora mismo, solo se estaría atrapando la primera letra de toda la cadena que hemos introducido.
9.2. Atrapando cadenas de caracteres con scanf
Sin embargo, también podemos modificar el programa para que admita una matriz de cadenas, y de esta forma, que nos permite leer varios caracteres de la línea.
En este código de ejemplo que se muestra a continuación, podemos observar como, al ejecutarlo, no solo se está obteniendo el primer carácter de la cadena introducida, sino que se está obteniendo toda la cadena en sí misma, hasta el límite de caracteres especificado en la matriz.
#include <stdio.h>

int main(int argc, char *argv[]) {
   printf("Introduce una tecla \n");
   char palabra[100];
   scanf("%s",palabra);
   printf("La palabra introducida es: %s \n",palabra);
        return 0;
}
	Gracias a esta función vamos a poder ser capaces no solo de atrapar un solo carácter por parte del usuario, sino de atrapar una cadena completa de caracteres, que tendrá evidentes usos y aplicaciones en el programa que estamos desarrollando, como veremos a continuación, durante el ejercicio del curso. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0023-entradacadena.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Introduce una tecla 
Vicente
La palabra introducida es: Vicente 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Por último, en el siguiente programa, realizamos una demostración para comprobar que somos capaces de pedirle al usuario una entrada, almacenarla en una variable, y devolverla en la consola.
#include <stdio.h>

int main(int argc, char *argv[]) {
   printf("Introduce una tecla \n");
   char palabra[100];
   scanf("%s",palabra);
   printf("La palabra introducida es: %s \n",palabra);
        return 0;
}
	Al ejecutar el programa, comprobamos cómo somos capaces de realizar una entrada por parte del usuario, y almacenarla en una variable que hemos declarado previamente, que consistirá en un arreglo de caracteres individuales, con una longitud máxima de 100 caracteres. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0024-entradavariable.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Introduce una tecla 
Vicente
La palabra introducida es: Vicente 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Evidentemente, más adelante, en las siguientes unidades, vamos a visualizar cómo, al haber atrapado esa información en una variable, podremos realizar operaciones de validación, para que el usuario, a través de esa entrada, pueda controlar el flujo de la información a lo largo de la aplicación
9.3. Ejercicio del curso
Aplicándolo sobre el ejercicio del curso:
En la versión anterior del ejercicio continuo de la publicación, nos habíamos quedado declarando una variable que, más adelante, almacenaría la opción que elige el usuario en cada una de las situaciones de ejecución del programa.
Así que, como aplicación práctica del ejercicio que desarrollamos a lo largo del curso, podremos comprobar que ahora a la variable opción, se le asignó una instrucción para capturar la entrada del usuario.
Por último, se introduce, de momento, a efectos de comprobar que el programa funciona correctamente, una instrucción de impresión en pantalla que simplemente se encarga de decir cuál es la opción escogida, simplemente para asegurarnos que se está recogiendo correctamente la instrucción, para, más adelante, a medida que vayamos cubriendo las siguientes unidades didácticas, poder actuar de una forma u otra en base a la elección que el usuario final realice.
📂proyectodelcurso/   📄main.c
	/* Programa agenda
por Jose Vicente Carratala */
#include <stdio.h>
#define NOMBREPROGRAMA "Programa agenda"
#define VERSION "1.0"
#define AUTOR "Jose Vicente Carratala"

int main(int argc, char *argv[]) {
   // Mensaje de bienvenida
        printf("%s v%s \n",NOMBREPROGRAMA,VERSION);
        printf("%s \n",AUTOR);
        printf("\t 1 - Listado de registros \n");
        printf("\t 2 - Introducir un registro \n");
        printf("\t 3 - Eliminar un registro \n");
        printf("\t 4 - Buscar un registro \n");
        printf("\t 5 - Actualizar un registro \n");
        printf("Tu opcion: ");
        char opcion = getchar();
        printf("La opción que has seleccionado es: %c \n",opcion);
        return 0;
}
	Más adelante durante la ejecución de versiones más avanzadas de este ejercicio, una vez que empecemos a introducir registros, los registros, si contienen nombres, teléfonos correos electrónicos etcétera, estarán compuestos de palabras formadas por más de un carácter.
Pero sin embargo , en el punto en el que nos encontramos dentro del desarrollo de este ejercicio, al usuario se le está pidiendo que introduzca un único carácter correspondiente al número de opción de las cuales se ofrecen en pantalla.
char opcion = getchar();
	Por lo tanto, si bien en los apartados anteriores hemos visto cómo en principio la instrucción scanf  parece más poderosa y más versátil que la instrucción getchar,  para esta parte del ejercicio vamos a utilizar una entrada de texto de tipo getchar  ya que únicamente deseamos atrapar un solo carácter. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0025-agendaentrada.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Programa agenda v1.0 
Jose Vicente Carratala 
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
Tu opcion: 1
La opción que has seleccionado es: 1 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Veremos cómo, antes de finalizar la ejecución del programa, la aplicación devuelve por pantalla el número de opción que ha seleccionado el usuario, simplemente para que, al menos en este punto, a nivel estético, podemos observar como el programa está atrapando correctamente la entrada del usuario.
________________


10. Operadores
________________


10.1. Qué son los operadores
El objetivo de este apartado es describir el uso y la utilidad de los diferentes tipos de operadores que se encuentran dentro de un lenguaje de programación.
La misión de los operadores es poder realizar operaciones usando dos o varios de los datos que, previamente, generalmente hemos almacenado en contenedores de información, tales como por ejemplo variables o matrices.
El resultado de estas operaciones es decisivo para poder especificar, por ejemplo, el flujo de la información de un programa en concreto.
Existen diferentes tipos de operadores, en los siguientes subapartados vamos a tratar aquellos más importantes y cuyo uso es, con diferencia, más frecuente.
10.2. Operadores aritméticos
Los operadores aritméticos son aquellos que nos permiten realizar operaciones matemáticas combinando las diferentes piezas de información.
El operador aritmético de suma, nos permite realizar una suma aritmética entre dos o más operandos.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int numero1 = 4;
   int numero2 = 3;
   int resultado = numero1 + numero2;
   printf("El resultado es: %i \n",resultado);
        return 0;
}
	Al ejecutar este programa en la consola, podremos comprobar como la variable resultado guarda la suma aritmética entre el operador número 1 y el operador número dos, devolviendo la , por último, por pantalla. 
​​MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0026-operadoresaritmeticos.c
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El resultado es: 7 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	El operador aritmético de restar, representado por un guión, nos permite realizar una diferencia entre dos o más operandos, aunque generalmente se trabajan con dos piezas de información.
int resultado = numero1 - numero2;
	El operador aritmético de multiplicación, representado por un*, nos permite multiplicar dos o más operandos.
int resultado = numero1 * numero2;
	El operador aritmético de división, representado por una barra, que usualmente podemos obtener con la combinación de mayúsculas y el número siete del teclado, en el teclado español, nos permite dividir dos operandos.
#include <stdio.h>

int main(int argc, char *argv[]) {
   float numero1 = 4;
   float numero2 = 3;
   float resultado = numero1 / numero2;
   printf("El resultado es: %f \n",resultado);
        return 0;
}
	Debemos tener en cuenta como el operador aritmético de división, en una gran cantidad de casos, acaba arrojando decimales aún si los operandos de base son números enteros. Por lo tanto, para que esté ejercicio funcione de forma óptima, es importante declarar los tipos de variable de los tres identificadores como flotantes. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0027-division.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El resultado es: 1.333333 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Existe un operador específico para obtener el resto de la división entera, que suele ser el de el símbolo del porcentaje.
Al usar este operador, el resultado que obtendremos en pantalla es el resto de la división entera entre dos operandos.
Si bien este operador no es de uso común a diario, de vez en cuando puede sernos de utilidad, por ejemplo para realizar operaciones relacionadas con el cálculo financiero.
float resultado = numero1 % numero2;
	10.3. Orden de precedencia en las operaciones aritméticas.
Al igual que ocurre en el mundo matemático, hay que tener en cuenta que, en prácticamente cualquier lenguaje de programación, se siguen las mismas reglas de procedencia que encontramos en el mundo de las matemáticas.
De esta manera, deberemos tener en cuenta que las operaciones de multiplicación y de división se resolverán siempre antes que las operaciones de suma y de resto.
Por otra parte, y una vez más, igual que en el mundo matemático, podemos alterar el orden de la preferencia mediante el uso de paréntesis.
El uso de paréntesis, por tanto, nos permite invertir el orden para especificar que las sumas se ejecuten antes que las multiplicaciones, por poner un ejemplo.
De la misma forma, las operaciones se pueden admirar de manera múltiple utilizando diferentes conjuntos de paréntesis. Esto, de hecho, es muy normal en programas complejos, y a la vez, suele ser frecuente fuente de errores.
Es por esto que debemos tener a la hora de maletas las diferentes combinaciones de paréntesis.
es muy frecuente, en el mundo de la programación, ver el uso de paréntesis, para indicar, sobre todo entre diferentes programadores, cuál es el orden en el que se deben resolver las operaciones, aún en casos en los que no sería necesario, ya que los paréntesis acaban indicando el mismo orden natural de procedencia.
Incluso en estos casos, ya que muchos programadores, sorprendentemente, desconocen cuáles son estas reglas de procedencia, suele ser útil el uso de paréntesis para asegurar que, sea como sea, se entiende el orden en el cual se van a repetir las operaciones en un . concreto de la programación.
10.4. Operadores de comparación
Existe un conjunto de operadores de comparación, que nos permiten, no voy a sumar, restar, o en definitiva realizar operaciones aritméticas sobre dos o más operadores, sino obtener el resultado verdadero o falso de una comparación entre dos o más operadores.
En esta unidad didáctica vamos a desarrollar una serie de ejemplos teniendo como referencia el uso de dos operadores.
La doble igualdad
Si bien el operador de igualdad se usa para realizar una asignación, es decir, cuando ponemos lo siguiente:
#include <stdio.h>

int main(int argc, char *argv[]) {
   float numero1 = 4;
   float numero2 = 3;
   int resultado = numero1 == numero2;
   printf("El resultado es: %d \n",resultado);
        return 0;
}
	Al ejecutar el código, en la terminal saldrá un cero, en el caso de que la comparación haya resultado falsa, y un número uno en el caso de que la comparación haya resultado verdadera. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0028-operadorigualdad.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El resultado es: 0 
	Lo que le estamos queriendo decir a la máquina es que a una variable le asignamos un valor, cuando introducimos expresiones, es muy normal encontrar una doble igualdad.
A los ojos inexpertos puede parecer una asignación, pero sin embargo, Suso no tiene nada que ver con esta.
En el momento en el que vemos una doble igualdad, estamos viendo que el programa comprobar si es cierto que el operando a es igual al operando B.
Debemos recordar, por tanto, que siempre que vemos una doble igualdad, en cierta forma, es como si estuviéramos viendo una pregunta.
Así que, una vez más, sobre el ejemplo anterior, cuando vemos esto:
Lo que realmente tenemos que pensar en nuestra cabeza es que el programa está diciendo: ¿es cierto que el operando va es igual al operando B? La respuesta, evidentemente, será verdadera o falsa
El operador not equal
De la misma forma que podemos evaluar si un operando es igual a otro, podemos evaluar si un operando no es igual a otro.
Es decir, es como una operación de igualdad, pero en negativo.
En C, y en la mayoría de lenguajes de programación, el operador de negación es el signo de admiración cerrado.
Así que, de esta forma, el ejemplo siguiente evaluaría la pregunta de si el operando B no es igual al operando A.
#include <stdio.h>

int main(int argc, char *argv[]) {
   float numero1 = 4;
   float numero2 = 3;
   int resultado = numero1 != numero2;
   printf("El resultado es: %d \n",resultado);
        return 0;
}
	Debemos tener en cuenta que, en este caso, la lógica de la operación es la contraria. Es decir, la comparación de la verdadera si los operandos comparados no son iguales, y la operación de comparación dará falsa si los dos operandos comparados son iguales. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0029-notequal.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El resultado es: 1 
	Los operadores “mayor que” y “menor que”
Las operaciones de evaluación de si el operando a es menor que el operando B, o el operando a es mayor que el operando B, se escriben de la siguiente forma.
Disponemos de una evaluación de menor, otra aplicación de menor o igual, de la misma forma, que disponemos de una evaluación de mayor, y una evaluación de mayor o igual.
Deberemos tener en cuenta que, en cualquiera de los dos casos, en la gran mayoría de lenguajes de programación, primero se pone los símbolos de menor o mayor, y luego se pone el símbolo de igualdad, y nunca al revés.
Además, no debe existir ningún espacio entre los dos, ya que entonces el programa lo interpreta como dos operadores diferentes, y da error en la gran mayoría de los casos.
#include <stdio.h>

int main(int argc, char *argv[]) {
   float numero1 = 4;
   float numero2 = 3;
   int resultado = numero1 < numero2;
   printf("El resultado es: %d \n",resultado);
        return 0;
}
	En la ejecución de este ejemplo de código, mediante el cual el resultado guarda la comparación entre el valor del número 1 con respecto al valor del número dos, en el caso de que el valor del número uno sea menor que el valor del número dos, la comparación dará cierta, y en caso contrario, dará falsa.
Recordamos que en la terminal aparecerá un número uno en el caso de que la comparación resulte cierta, y un número cero en el caso de que resulte falsa.
Deberemos también tener en cuenta que depende, en gran medida, del compilador, que el carácter devuelto en pantalla sea un 1 o un 0, o bien sea la palabra True o la palabra False, o en ocasiones devuelve un número 1 en el caso de que sea cierto , o nada en el caso de que sea falso. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0030-mayorque.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El resultado es: 0
	10.5. Operadores lógicos
Los operadores lógicos and y or se encargan de evaluar multitud de expresiones de una sola vez.
El operador lógico and,
En primer lugar, en el operador lógico anda, se evalúa que dos o más conjuntos de evaluaciones sean verdaderos o falsos, con la característica de que con que uno de los operandos evaluados sea falso, la globalidad de la expresión es falsa.
Un ejemplo sería el siguiente, cuya evaluación de falso.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int numero1 = 4;
   int numero2 = 3;
   int numero3 = 5;
   int numero4 = 5;
   int resultado = numero1 == numero2 && numero3 == numero4;
   printf("El resultado es: %i \n",resultado);
        return 0;
}
	En el momento en el que una de las dos expresiones es falsa, el resultado global resulta ser falso.
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0067and.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El resultado es: 0 
	

Otro ejemplo sería el siguiente, cuya evaluación da verdadero.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int numero1 = 4;
   int numero2 = 3;
   int numero3 = 5;
   int numero4 = 5;
   int resultado = numero1 != numero2 && numero3 == numero4;
   printf("El resultado es: %i \n",resultado);
        return 0;
}
	Al ejecutar el código, comprobamos que el resultado es verdadero. Recordemos que en muchos sistemas, el valor verdadero se representa con el número 1, y el valor falso con el número 0
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0068-and2.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El resultado es: 1 
	



En los dos ejemplos puestos con anterioridad, se están evaluando tres expresiones de manera simultánea, pero evidentemente es solo un ejemplo, se pueden evaluar tantas expresiones como se quiera, sin límite.
El operador lógico or.
El operador lógico ahora es algo más permisivo que el operador ando, en términos de que, cuando se evalúan una serie de expresiones, con que una de ellas sea cierta, el resultado global de la comparación es cierto.
Es decir, volviendo a los ejemplos anteriores, pero transformándolos al caso por, tendríamos este primer ejemplo, donde todos los resultados son verdaderos, luego la expresión global es verdadera.
Tenemos este otro ejemplo, donde dos casos son falsos, pero uno es verdadero, así que la expresión global se valida como verdadera.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int numero1 = 3;
   int numero2 = 4;
   int numero3 = 5;
   int numero4 = 6;
   int numero5 = 7;
   int numero6 = 7;
   int resultado = numero1 == numero2 || numero3 == numero4 || numero5 == numero6;
   printf("El resultado es: %i \n",resultado);
        return 0;
}
	Al ejecutar el código comprobaremos que el resultado valida como cierto, cuando una de las expresiones validadas es cierta.
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0069-or.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El resultado es: 1
	Y luego por supuesto tenemos este otro ejemplo, donde las tres sub expresiones validadas son falsas, luego la expresión global válida como falsa.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int numero1 = 3;
   int numero2 = 4;
   int numero3 = 5;
   int numero4 = 6;
   int numero5 = 7;
   int numero6 = 8;
   int resultado = numero1 == numero2 || numero3 == numero4 || numero5 == numero6;
   printf("El resultado es: %i \n",resultado);
        return 0;
}
	Comprobamos como, si ninguna de las parejas evaluadas resulta ser cierta, la expresión global retorna un valor falso
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0070-or2.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El resultado es: 0
	10.6. Operadores de incremento y decremento
Durante el desarrollo de programas informáticos en la gran mayoría de lenguajes, es muy común necesitar realizar operaciones de incremento y decremento, donde, respectivamente, se realizan incrementos y restas sobre los valores de las variables que se están tratando
De esta forma, a continuación se presenta un ejemplo de incremento, que básicamente consiste en llamar a la variable con el doble operador más
#include <stdio.h>

int main(int argc, char *argv[]) {
   int numero1 = 3;
   printf("El valor del número es: %i \n",numero1);
   numero1++;
   printf("Ahora el valor del número es: %i \n",numero1);
        return 0;
}
	Al ejecutar el programa, comprobamos como el operador de incremento le añade un valor numérico a la variable.
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0071-incremento.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El valor del número es: 3 
Ahora el valor del número es: 4 
	Por otra parte, observamos también en el siguiente ejemplo el uso de los operadores de decremento, que nos permiten restar una unidad a la variable en cuestión, en cada una de las ejecuciones del código.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int numero1 = 3;
   printf("El valor del número es: %i \n",numero1);
   numero1--;
   printf("Ahora el valor del número es: %i \n",numero1);
        return 0;
}
	El operador de decremento, en cambio, le resta un valor a la variable inicial
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0072-decremento.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El valor del número es: 3 
Ahora el valor del número es: 2
	

10.7. operadores abreviados
Los operadores de incremento y decremento sirven para sumar y restar un valor, respectivamente. nueva línea nueva línea sin embargo, en el momento en el que queremos realizar un incremento de dos valores consecutivamente, nos damos cuenta de que simplemente no existe esta opción es prácticamente ningún lenguaje de programación
De esta forma, es como nos encontramos con los operadores aritméticos abreviados
Por poner un ejemplo, si lo que queremos es sumar 2 unidades a una variable previamente existente, podríamos hacerlo de la siguiente forma
#include <stdio.h>

int main(int argc, char *argv[]) {
   int numero1 = 3;
   printf("El valor del número es: %i \n",numero1);
   numero1 = numero1 + 2;
   printf("Ahora el valor del número es: %i \n",numero1);
        return 0;
}
	El código anterior funciona, desde el punto de vista en el que suma dos valores a la variable inicial.
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El valor del número es: 3 
Ahora el valor del número es: 5
	Pero sin embargo, esa sintaxis no se recomienda, y se recomienda utilizar el operador abreviado de la siguiente forma
#include <stdio.h>

int main(int argc, char *argv[]) {
   int numero1 = 3;
   printf("El valor del número es: %i \n",numero1);
   numero1 += 2;
   printf("Ahora el valor del número es: %i \n",numero1);
        return 0;
}
	Al ejecutar el programa, podremos comprobar como el operador abreviado le suma dos unidades a la variable inicial
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0074-opsuma.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El valor del número es: 3 
Ahora el valor del número es: 5
	Así que por tanto, si hemos expuesto el operador abreviado de suma, a continuación se muestra el operador abreviado de resta
#include <stdio.h>

int main(int argc, char *argv[]) {
   int numero1 = 3;
   printf("El valor del número es: %i \n",numero1);
   numero1 -= 2;
   printf("Ahora el valor del número es: %i \n",numero1);
        return 0;
}
	El operador abreviado de resta, le resta dos unidades enteras al valor inicial de la variable.
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0075-opresta.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El valor del número es: 3 
Ahora el valor del número es: 1
	

Este sería el operador a primero de multiplicación
#include <stdio.h>

int main(int argc, char *argv[]) {
   int numero1 = 3;
   printf("El valor del número es: %i \n",numero1);
   numero1 *= 2;
   printf("Ahora el valor del número es: %i \n",numero1);
        return 0;
}
	Al igual que ha ocurrido en los ejemplos anteriores, el operador abreviado realiza una multiplicación sobre el valor inicial de la variable
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0076-opmultiplicacion.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El valor del número es: 3 
Ahora el valor del número es: 6 
	Y por último el operador abreviado de división
#include <stdio.h>

int main(int argc, char *argv[]) {
   int numero1 = 3;
   printf("El valor del número es: %i \n",numero1);
   numero1 /= 2;
   printf("Ahora el valor del número es: %i \n",numero1);
        return 0;
}
	Al ejecutar el ejemplo, comprobaremos que se realiza la división sobre el valor inicial de la variable
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0077-opdivision.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El valor del número es: 3 
Ahora el valor del número es: 1
	Para el usuario novel en un primer momento y pueden resultar difíciles de comprender, pero sin embargo, con un poco de práctica, podremos observar como suponen evidentemente una ventaja desde el . de vista de la cantidad de código que se escribe para conseguir el mismo objetivo 




________________


11. Estructuras de control
________________


11.1. ¿Qué son las estructuras de control?
Las estructuras que vamos a ver en este capítulo nos permiten controlar el flujo de la información a lo largo de un programa.
Un programa, tal y como lo hemos visto hasta ahora, es una sucesión de instrucciones que acaban llevando a un resultado fijo y concreto.
Sin embargo, hay ocasiones en las que un programa no tiene un único resultado, sino que puede tener diferentes resultados, puede tener diferentes secciones, y la ejecución de unas secciones uno tras dependerá de las decisiones que nosotros tomemos durante la ejecución de dicho programa.
El objetivo de este apartado, es precisamente presentar y mostrar estas estructuras de control, que forman parte Del núcleo de cualquier lenguaje de programación, y además, encontraremos las mismas estructuras, o prácticamente iguales, a lo largo de diferentes lenguajes, durante nuestro proceso de aprendizaje.
11.2. Estructuras condicionales
El flujo de ejecución de un programa puede ser modificado mediante la aparición de estructuras condicionales, es decir, mediante la ejecución condicional de un código u otro, después de la validación de una condición previa.
fundamentalmente existen dos tipos de estructura condicional, que son las que vamos a presentar a continuación.
La primera es la estructura condicional es, que se encarga de ejecutar un código y otro mediante la validación verdadero falso de una expresión, y la segunda es la estructura condicional switch, que admite varios casos de manera simultánea como verdadero
11.2.1. La estructura condicional if
Anteriormente hemos hablado de que el lenguaje nativo en el que habla una computadora es el binario, compuesto de unos y ceros, que, finalmente, representan el estado encendido y apagado de cada uno de los componentes más básicos del lenguaje de programación.
Así que, finalmente, la validación mediante estados de verdadero y falso es una validación bastante cercana para lo que es la naturaleza del lenguaje con el que trabaja la máquina, a diferencia del lenguaje con el que trabaja el ser humano, que entre blanco y negro distingue una variedad bastante grande de grises, por regla general.
La estructura de control, por tanto, contiene en primer lugar una expresión que, finalmente, puede ser validada como verdadera o cierta.
A continuación, tiene un bloque de código, que solo se ejecutará en el caso de que la expresión validada sea cierta.
Adicional y opcionalmente, la expresión puede tener un caso Els, es decir, un caso que solo se ejecutará en el caso de que la expresión haya sido validada como falsa.
Es por esto que, por ejemplo, podríamos expresar una estructura de control es de la siguiente manera:
#include <stdio.h>

int main(int argc, char *argv[]) {
   int edad = 40;
   if(edad < 30){
       printf("Eres un joven");
   }else{
       printf("Ya no eres tan joven");
   }
        return 0;
}
	Al ejecutar este programa , podremos comprobar como, en un primer momento, asignamos el valor de 40 a la variable de edad, y tras realizar una comprobación mediante una estructura de control condicional, no es cierto que La edad sea menor que 30, con lo cual no sé ejecuta el código correspondiente al caso verdadero, sino que se ejecuta el código correspondiente al caso falso 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0031-if.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Ya no eres tan joven
	11.2.2. Anidación de las estructuras de control condicionales
Las estructuras de control pueden ser perfectamente anidadas, para ofrecer validaciones más complejas que el ejemplo que hemos visto con anterioridad.
De esta forma, con respecto al ejemplo anterior, dentro de cada uno de los casos, podemos introducir a su vez otra estructura completa de validación condicional.
Si aplicamos esta validación sobre el ejercicio que mostrado anteriormente, podemos encontrar que, ahora, la salida del programa, ya no se limita a dos estados, sino que puede resultar en cuatro.
Evidentemente, puedo repetir este proceso iterativamente tantas veces como necesites, para conseguir que la estructura general tantos estados como yo necesite
#include <stdio.h>

int main(int argc, char *argv[]) {
   int edad = 40;
   if(edad < 30){
       if(edad < 20){
           printf("Eres muy joven");
       }else{
           printf("Eres un joven");
       }
       
   }else{
       if(edad < 40){
          printf("Ya no eres tan joven"); 
       }else{
           printf("Definitivamente ya no eres joven");
       }
       
   }
        return 0;
}
	Las operaciones de anidación, por regla general, no se recomiendan dentro de cualquier lenguaje de programación, y exactamente lo mismo ocurre en el lenguaje de programación C.
Una aplicación excesiva puede causar, eventualmente, problemas en el rendimiento de las aplicaciones informáticas, y precisamente uno de los puntos claves de las razones por las cuales podemos desear utilizar este lenguaje de programación consiste en realizar aplicaciones que desarrollen un rendimiento óptimo.
Por lo tanto, si viene a continuación, en la línea de comando, podemos comprobar como la ejecución anidada de estructuras de control funciona perfectamente, deberemos evitar, siempre que podamos, realizar tales anizaciones. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0032-anidacion.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out
	

11.2.3. La estructura de control condicional switch
Hasta el momento, con la estructura de Control condicional ismos o Els es, finalmente lo que hacemos es validar una expresión en cuanto a su veracidad o su falsedad.
Sin embargo, existen infinidad de casos donde no hay una validación verdadera y una falsa, sino que puede haber muchas variaciones verdaderas infinitas validaciones falsas.
Un ejemplo claro y clásico de esto, son los días de la semana.
Si yo pregunto, ¿qué día de la semana es hoy? La respuesta a esa pregunta no es verdadera o falsa.
Las respuestas correctas son lunes, martes, miércoles, jueves, viernes, sábado, y domingo, y hay infinidad de otras respuestas incorrectas, pero en definitiva sabemos que hay al menos siete respuestas verdaderas.
La estructura de control switch trata específicamente este tipo de preguntas, en definitiva, preguntas para las que no hay un solo caso verdadero.
Así que, el ejemplo planteado en el párrafo anterior, el ejemplo de los días de la semana, quedaría reflejado en el siguiente código
#include <stdio.h>

int main(int argc, char *argv[]) {
   int dia = 1;
   
   switch(dia){
       case 1:
           printf("Hoy es lunes");
           break;
       case 2:
           printf("Hoy es martes");
           break;
       case 3:
           printf("Hoy es miercoles");
           break;
       case 4:
           printf("Hoy es jueves");
           break;
       case 5:
           printf("Hoy es viernes");
           break;
       case 6:
           printf("Hoy es sabado");
           break;
       case 7:
           printf("Hoy es domingo");
           break;
   }
        return 0;
}
	Al ejecutar este programa en la consola o en la terminal, podremos comprobar cómo, en base al día de la semana que hayamos elegido de forma numérica, podremos sacar un resultado o otro a través de la pantalla. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0033-switch.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hoy es lunes
	Como podemos ver, a la estructura de control tiene una serie de componentes similares a cualquier otra estructura, tiene el nombre de la propia estructura, entre paréntesis la expresión que se está validando, y dentro de las llaves, se escriben cada uno de los casos que trata la expresión como posibles casos válidos.
Debemos fijarnos en que lo que hay después de la palabra clave caso son dos puntos y no un punto y coma.
Por otra parte, también deberemos tener en cuenta que cada uno de los casos deberá acabar con una instrucción break.
Una vez que se ha ejecutado uno de los casos verdaderos, la instrucción break impide que se ejecuten el resto de casos en cascada.
11.2.4. El caso default
En el ejemplo anterior, en el caso switch, hemos visto cómo la estructura de control puede reaccionar a una serie de casos verdaderos, pero, ¿qué es lo que ocurre cuando se introduce un caso falso?
Por defecto, cuando ocurre que el usuario introduce un caso que no es válido, por defecto la estructura de control no realiza una acción.
De esta forma, siguiendo los patrones de la programación defensiva, existe un último caso dentro de la estructura switch llamado de Ford, que se encarga de gestionar precisamente como debe comportarse la estructura de control cuando se le introduce un caso no válido.
De esta forma, la estructura de control quedaría de la siguiente manera:
#include <stdio.h>

int main(int argc, char *argv[]) {
   int dia = 15;
   
   switch(dia){
       case 1:
           printf("Hoy es lunes");
           break;
       case 2:
           printf("Hoy es martes");
           break;
       case 3:
           printf("Hoy es miercoles");
           break;
       case 4:
           printf("Hoy es jueves");
           break;
       case 5:
           printf("Hoy es viernes");
           break;
       case 6:
           printf("Hoy es sabado");
           break;
       case 7:
           printf("Hoy es domingo");
           break;
       default:
           printf("Entrada no reconocida");
           break;
   }
        return 0;
}
	En el caso de que aquello que hayamos introducido no sea realmente un día de la semana válido, se ejecutará el caso de fold, mediante el cual podemos atrapar todo aquello que no sea una entrada válida. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0034-default.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Entrada no reconocida
	Como habremos podido comprobar, en el lenguaje de programación C, la estructura de control switch se realiza únicamente pudiendo evaluar un número, y no nos permite evaluar directamente cadenas de caracteres.
Es decir, hemos tenido que introducir el día numérico de la semana, y no podemos introducir la cadena de caracteres alfanuméricos que nos permita validar, por ejemplo, la palabra “ lunes”  hola palabra “ martes”
Sin embargo, como a continuación podemos comprobar , podemos hacer uso de una variación especial de la estructura de control if else para conseguir este efecto. 
11.2.5. La estructura de control condicional else if
Prácticamente el mismo resultado que hemos conseguido mediante el uso de la estructura de control switch, podríamos conseguirlo mediante la estructura de control el cif, que en principio es una variación a la estructura de control y que ha sido presentado anteriormente
 el ejercicio, de esta manera, quedaría transformado en el siguiente código 
#include <stdio.h>

int main(int argc, char *argv[]) {
   int dia = 1;
   
   if(dia == 1){
       printf("Hoy es lunes");
   }else if(dia == 2){
       printf("Hoy es martes");
   }else if(dia == 2){
       printf("Hoy es miercoles");
   }else if(dia == 2){
       printf("Hoy es jueves");
   }else if(dia == 2){
       printf("Hoy es viernes");
   }else if(dia == 2){
       printf("Hoy es sabado");
   }else if(dia == 2){
       printf("Hoy es domingo");
   }else{
       printf("Entrada no reconocida");
   }
   
        return 0;
}

	Sin embargo, procediendo de esta manera, no estaremos evaluando realmente el potencial que tiene la estructura de control el cif, ya que en cada una de las condiciones evaluadas, podemos introducir un nivel mayor de complejidad que en la estructura de control switch
De esta forma, el siguiente ejemplo aprovecha bastante mejor el potencial de extra estructura, comparada con la estructura de control switch 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0086-elseif.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hoy es lunes
	11.2.6. Ejercicio del curso:
A continuación aplicamos lo que hemos aprendido en la presente unidad didáctica al desarrollo del ejercicio continuo de la publicación
Si en unidades anteriores hemos preparado una variable de tipo carácter para almacenar la elección del usuario, a continuación, utilizamos una estructura de control de tipo suite para poder reaccionar de diferente forma dependiendo de la elección que efectivamente haya realizado el usuario humano 
 📄main.c
	/* Programa agenda
por Jose Vicente Carratala */
#include <stdio.h>
#define NOMBREPROGRAMA "Programa agenda"
#define VERSION "1.0"
#define AUTOR "Jose Vicente Carratala"

int main(int argc, char *argv[]) {
   // Mensaje de bienvenida
        printf("%s v%s \n",NOMBREPROGRAMA,VERSION);
        printf("%s \n",AUTOR);
        printf("\t 1 - Listado de registros \n");
        printf("\t 2 - Introducir un registro \n");
        printf("\t 3 - Eliminar un registro \n");
        printf("\t 4 - Buscar un registro \n");
        printf("\t 5 - Actualizar un registro \n");
        printf("Tu opcion: ");
        char opcion = getchar();
        printf("La opción que has seleccionado es: %c \n",opcion);
        switch(opcion){
            case '1':
                printf("Vamos a listar los registros");
                break;
       case '2':
                printf("Vamos a introducir un registro");
                break;
       case '3':
                printf("Vamos a eliminar un registro");
                break;
       case '4':
                printf("Vamos a buscar un registro");
                break;
            case '5':
                printf("Vamos a actualizar un registro");
                break;
       default:
           printf("La opción que has introducido no es válida");
           break;
        }
        return 0;
}
	Al ejecutar este código, podremos comprobar como ahora somos capaces de capturar la entrada del usuario, sino que podemos evaluar esa entrada del usuario mediante una estructura switch, y prepararemos a nuestro programa para poder ejecutar un bloque de código u otro, en función de lo que el usuario haya introducido. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0035-agenda.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Programa agenda v1.0 
Jose Vicente Carratala 
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
Tu opcion: 1
La opción que has seleccionado es: 1 
Vamos a listar los registros
	11.3. Estructuras de bucle
Las estructuras de control del bucle nos permiten repetir la ejecución de una serie de instrucciones.
En ocasiones, es necesario una cierta parte del programa un número determinado, o incluso indeterminado de veces.
De esta forma, cuando en un programa repetimos varias veces una pieza del código, debemos saber que existen varios tipos de estructuras que nos permiten automatizar este proceso.
Un ejemplo bastante típico y característico serían los días de un calendario mensual.
Supongamos que queremos representar los 30 días estándar de un mes, por lo que el código necesario tendría un aspecto aproximadamente como el siguiente.
Cuando en un programa vemos que se repite una porción del código, nuestra mente del programador debe advertirnos de que debería haber una forma a más sencilla de representar esa parte del código.
A continuación, vamos a ver de qué herramientas de control de bucle disponemos.
11.3.1. La estructura de control for.
La estructura de control for, tiene la sintaxis que vemos en el ejemplo anterior, de la cual podemos destacar, que primero introducimos la palabra reservada favor, a continuación, dentro de los paréntesis, introducimos las tres condiciones, de inicio, de finalización, y de incremento, y por último, dentro de las llaves, introducimos el código que se va a repetir.
De esta forma, el ejemplo del calendario quedaría representado de la siguiente manera.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int diasDelMes = 30;
   for(int i = 1;i<diasDelMes;i++){
       printf("Hoy es un día \n");
   }
}
	Al ejecutar este bloque de código, vamos a poder comprobar cómo, habiendo escrito una única vez una instrucción de salida por pantalla, sin embargo el programa, al ejecutarse , la saca 30 veces, qué es la cantidad de iteraciones que hemos indicado que queremos procesar. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0044-for.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
Hoy es un día 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Como podemos comprobar, constituye una forma muy conveniente de repetir la ejecución.
Además, nos podremos fijar de que a lo largo de la utilización del buque favor, se define una variable, que recibe el nombre de variable y te Ladora.
Es por esta razón que la letra elegida para ocupar esta función suele ser la letra vocal y, aunque podemos comprobar, que esta función puede ser desarrollada por cualquier variable.
En el ejemplo amor mostrado, podremos comprobar como la variable empieza en el día número uno del mes, llega hasta el día 30 del mes, y cada vez que ejecutamos el bucle, es decir, cada vez que se repite el bucle, encontramos un nuevo día más añadido al bucle de información.
Además, la variable utilizada como integradora, se puede usar dentro de las llaves, dentro del código que se utiliza en el programa.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int diasDelMes = 30;
   for(int i = 1;i<=diasDelMes;i++){
       printf("Hoy es el dia %i del mes \n",i);
   }
}
	Al introducir la variable de iteración dentro de la propia cadena que sacamos por pantalla, podemos obtener un resultado más personalizado , ya que en cada una de las iteraciones estamos sacando, además de la cadena alfanumérica, el día del mes. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0045-for2.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hoy es el dia 1 del mes 
Hoy es el dia 2 del mes 
Hoy es el dia 3 del mes 
Hoy es el dia 4 del mes 
Hoy es el dia 5 del mes 
Hoy es el dia 6 del mes 
Hoy es el dia 7 del mes 
Hoy es el dia 8 del mes 
Hoy es el dia 9 del mes 
Hoy es el dia 10 del mes 
Hoy es el dia 11 del mes 
Hoy es el dia 12 del mes 
Hoy es el dia 13 del mes 
Hoy es el dia 14 del mes 
Hoy es el dia 15 del mes 
Hoy es el dia 16 del mes 
Hoy es el dia 17 del mes 
Hoy es el dia 18 del mes 
Hoy es el dia 19 del mes 
Hoy es el dia 20 del mes 
Hoy es el dia 21 del mes 
Hoy es el dia 22 del mes 
Hoy es el dia 23 del mes 
Hoy es el dia 24 del mes 
Hoy es el dia 25 del mes 
Hoy es el dia 26 del mes 
Hoy es el dia 27 del mes 
Hoy es el dia 28 del mes 
Hoy es el dia 29 del mes 
Hoy es el dia 30 del mes 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Podemos variar el código tanto como necesitemos, para realizar, por ejemplo, las siguientes variaciones.
El siguiente ejemplo, muestra los días únicamente impares del mes.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int diasDelMes = 30;
   for(int i = 1;i<=diasDelMes;i+=2){
       printf("Hoy es el dia %i del mes \n",i);
   }
}
	Al personalizar el iterador podemos no solo sacar todos los días de uno en uno, sino que, por ejemplo, como en el ejemplo que ejecutamos a continuación, sacamos únicamente los días impares. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0046-forincremento.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hoy es el dia 1 del mes 
Hoy es el dia 3 del mes 
Hoy es el dia 5 del mes 
Hoy es el dia 7 del mes 
Hoy es el dia 9 del mes 
Hoy es el dia 11 del mes 
Hoy es el dia 13 del mes 
Hoy es el dia 15 del mes 
Hoy es el dia 17 del mes 
Hoy es el dia 19 del mes 
Hoy es el dia 21 del mes 
Hoy es el dia 23 del mes 
Hoy es el dia 25 del mes 
Hoy es el dia 27 del mes 
Hoy es el dia 29 del mes 
MacBook-Pro-de-Jose:cursodec josevicente$ 

	El siguiente ejemplo, muestra los días únicamente pares del mes.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int diasDelMes = 30;
   for(int i = 2;i<=diasDelMes;i+=2){
       printf("Hoy es el dia %i del mes \n",i);
   }
}
	De forma parecida al ejercicio anterior, si el primer día es el día número dos, en lugar de ser el día número uno, y alcanzamos a través del iterador de dos en dos, obtendremos como resultado todos los días pares del mes. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0047-forpares.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hoy es el dia 2 del mes 
Hoy es el dia 4 del mes 
Hoy es el dia 6 del mes 
Hoy es el dia 8 del mes 
Hoy es el dia 10 del mes 
Hoy es el dia 12 del mes 
Hoy es el dia 14 del mes 
Hoy es el dia 16 del mes 
Hoy es el dia 18 del mes 
Hoy es el dia 20 del mes 
Hoy es el dia 22 del mes 
Hoy es el dia 24 del mes 
Hoy es el dia 26 del mes 
Hoy es el dia 28 del mes 
Hoy es el dia 30 del mes 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	El siguiente ejemplo muestra los días pares empezando en el 10, y acabando en el 20.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int diasDelMes = 30;
   for(int i = 10;i<=20;i+=2){
       printf("Hoy es el dia %i del mes \n",i);
   }
}
	Podemos personalizar no solo el incremento, sino también el día de inicio y el día de finalización. en definitiva, el objetivo de esta serie de ejercicios consiste en demostrar cómo podemos personalizar las tres condiciones de un bucle iterador for 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0048-foriniciofinal.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hoy es el dia 10 del mes 
Hoy es el dia 12 del mes 
Hoy es el dia 14 del mes 
Hoy es el dia 16 del mes 
Hoy es el dia 18 del mes 
Hoy es el dia 20 del mes 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Además, el iterador no tiene porque ir desde un número inferior hasta un número superior.
En el siguiente ejemplo se muestra la enumeración de días del mes, desde el día 30, hasta el día uno.
11.3.2. la estructura de control While
Si bien la estructura de control llamada for resulta muy conveniente porque contiene, dentro de los paréntesis, tanto la condición de inicio, como la condición de finalización, como la condición de incremento o decremento, la estructura de control de tipo while, tiene un formato parecido, en cuanto a que se invoca a la estructura, se pone entre paréntesis las condiciones, y se ejecuta el código a repetir entre las llaves, pero tiene la característica de que, dentro de los paréntesis, únicamente es posible poner la condición de finalización.
De esta forma, si por ejemplo escribimos el siguiente código, encontraremos que estamos ejecutando un bucle infinito.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int dia = 1;
   while(dia < 30){
       printf("Hoy es el dia %i del mes \n",dia);
   }
}
	Al ejecutar este bloque anterior de código, cosa que no recomiendo particularmente, comprobaremos que nuestra aplicación entrará no solo en un bucle de ejecución infinito, sino que dicho bucle será un bucle descontrolado.
Independientemente de si estamos en el sistema operativo Windows, Mac o ese , o Linux, podremos utilizar la combinación de teclas CONTROL C para finalizar la operación de forma abrupta en la consola.
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0049-whileinfinito.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hoy es el dia 1 del mes 
Hoy es el dia 1 del mes 
Hoy es el dia 1 del mes 
Hoy es el dia 1 del mes 
Hoy es el dia 1 del mes 
Hoy es el dia 1 del mes 
Hoy es el dia 1 del mes 
Hoy es el dia 1 del mes 
Hoy es el dia 1 del mes 
Hoy es el dia 1 del mes 
Hoy es el dia 1 del mes 
Hoy es el dia 1 del mes 
Hoy es el dia 1 del mes
	Es decir, podremos comprobar que no existe una condición de finalización, y por tanto, el programa entrará en una situación de ejecución constante sin fin.
Esto no es negativo, sino que existen diversos casos en los que puede interesarnos ejecutar un programa sin una finalización concreta . nueve
De todas formas, en el caso más típico y característico, es decir, en el caso de un bucle del cual esperamos poder controlar tanto el inicio, como al final, como en el incremento, formulamos el bucle while como podemos ver en el ejemplo a continuación.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int dia = 1;
   while(dia < 30){
       printf("Hoy es el dia %i del mes \n",dia);
       dia++;
   }
}
	Si ejecutamos este ejercicio, en el cual la condición de finalización está dentro de la expresión en la estructura de control, la condición de inicio está antes del bucle, y la condición de incremento está dentro del bucle, ahora sí, podremos comprobar que tenemos el control completo sobre la ejecución de este bucle 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0050-while.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hoy es el dia 1 del mes 
Hoy es el dia 2 del mes 
Hoy es el dia 3 del mes 
Hoy es el dia 4 del mes 
Hoy es el dia 5 del mes 
Hoy es el dia 6 del mes 
Hoy es el dia 7 del mes 
Hoy es el dia 8 del mes 
Hoy es el dia 9 del mes 
Hoy es el dia 10 del mes 
Hoy es el dia 11 del mes 
Hoy es el dia 12 del mes 
Hoy es el dia 13 del mes 
Hoy es el dia 14 del mes 
Hoy es el dia 15 del mes 
Hoy es el dia 16 del mes 
Hoy es el dia 17 del mes 
Hoy es el dia 18 del mes 
Hoy es el dia 19 del mes 
Hoy es el dia 20 del mes 
Hoy es el dia 21 del mes 
Hoy es el dia 22 del mes 
Hoy es el dia 23 del mes 
Hoy es el dia 24 del mes 
Hoy es el dia 25 del mes 
Hoy es el dia 26 del mes 
Hoy es el dia 27 del mes 
Hoy es el dia 28 del mes 
Hoy es el dia 29 del mes 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Cómo podremos ver, finalmente, al igual que en el bucle favor, existen la condición de inicio, de parada, y de incremento, con la diferencia de que en este ejemplo que se presenta, la condición de inicio está fuera del bucle, la condición de finalización está dentro de los paréntesis, y la condición de incremento se encuentra dentro del código del propio Google.
11.3.3. El bucle Do While
El bucle do while constituye una variación con respecto al bucle repetitivo guay que hemos visto con anterioridad.
El bucle while contiene una condición de finalización, en definitiva, una condición de ejecución, que hará que el bucle se ejecute mientras que esa condición sea cierta.
Si la condición no es cierta, el bucle no se ejecutará.
Si vemos por ejemplo el siguiente caso, podremos comprobar que, si la condición no es cierta, el bucle, de hecho, no se llega a ejecutar ni una sola vez.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int dia = 32;
   while(dia < 30){
       printf("Hoy es el dia %i del mes \n",dia);
       dia++;
   }
}
	Al ejecutar este código podremos comprobar como el contenido del bucle while no se llega a ejecutar en ningún momento, ya que la condición de parada proporciona un resultado falso en la primera ejecución.
Es decir , si el valor inicial de la variable dia = 32, y el bucle while únicamente debe ejecutarse cuando el día sea menor que 30, en ningún caso durante la ejecución del programa la condición resulta ser cierta, y por lo tanto el sistema no ejecuta ninguna ocurrencia de la estructura de control. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0051-dowhilewhile.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Precisamente para estos casos existe el bucle de do while.
Existen casos y situaciones, aunque honestamente no se dan todos los días, en los que es necesario que el contenido del bucle se ejecute al menos una vez, aunque su condición de validación no sea cierta.
Es por eso que este bucle, en ocasiones, recibe el nombre de " bucle de primero dispara y luego pregunta ".
En el ejemplo que presento a continuación, puede fácilmente visualizarse como, aunque el código no se debería ejecutar, ya que la condición de ejecución no es cierta, pero sin embargo, sí que se llega a ejecutar una vez.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int dia = 34;
   do{
       printf("Hoy es el dia %i \n",dia);
   }while(dia <= 30);
}
	Si ejecutamos esa estructura de control podremos comprobar cómo, en principio, si estuviéramos trabajando con una estructura de control while, el contenido de la estructura no debería ejecutarse en ningún caso.
Sin embargo, en el caso concreto de esta estructura de control, observamos que el código que contiene ejecuta una sola vez aún si la validación es falsa, porque la validación se produce después de la propia ejecución.
Por supuesto, si la validación es falsa, el bucle ya no se ejecutará ni una segunda vez ni en veces sucesivas, pero al menos una vez sí que se habrá ejecutado.
Una curiosidad con respecto a la estructura de control to wild, es que es la única estructura de control que se cierra utilizando un punto y coma, a diferencia del resto de estructuras de control. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0052-dowhile.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hoy es el dia 34 
	Como podemos comprobar, primero se ejecuta el código, y luego se valida la veracidad de la expresión evaluada.
El problema estriba en que si la condición es falsa, para cuando es evaluada, el código ya se ha ejecutado una vez.
Por supuesto, al validar, falsa, el código no se volverá a ejecutar, a menos que en un momento la condición sea cierta de nuevo.
Por último, es importante notar que el bucle do while es el único que es obligatorio finalizar con un punto y coma, a diferencia del resto de estructuras de control.
11.3.4. la estructura de control for en arreglos (for each)
Cuando hemos guardado la información en un arreglo, es muy común, en un momento dado, más adelante con respecto al momento del guardado, necesitamos recuperar la información contenida en esa matriz.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int longitud = 3;
   int telefono[longitud];
   telefono[0] = 12345;
   telefono[1] = 23456;
   telefono[2] = 34567;
   for(int i = 0;i<longitud;i++){
       printf("El teléfono es: %i \n",telefono[i]);
   }
        return 0;
}
	

De esta forma, es perfectamente posible recordar el contenido del arreglo usando una estructura de control de tipo for.
Esto puede hacerse, introduciendo manualmente la longitud de la matriz, o bien, usando la propiedad de longitud de la matriz.
13.8. La estructura de control goto:
En muchos de los primeros lenguajes de programación, sobre todo en lenguajes de programación de bajo nivel, existía una estructura de control llamada goto,  o lo que es lo mismo “go to”,  que nos permite modificar el flujo de la ejecución de un programa, de forma completamente arbitraria, utilizando etiquetas de destino.
Un ejemplo de programa que utiliza este tipo de estructura es el que se presenta a continuación. 
#include <stdio.h>

int main(int argc, char *argv[]) {
        primero:
            printf("Primero ejecuto esto \n");
       goto tercero;
   segundo:
       printf("Por último ejecuto esto \n");
       goto final;
   tercero:
            printf("A continuación ejecuto esto \n");
       goto segundo;
   final:
           return 0;
}
	Dentro de este ejemplo de código podemos comprobar cómo aparecen, por una parte, una serie de puntos de anclaje definidos por un identificador, y a continuación dos puntos.
En el ejemplo anterior de código, el código se ha sangrado dentro de los identificadores  simplemente por claridad, pero el sangrado, al igual que en el resto del lenguaje de programación, no es obligatorio.
A continuación, en aquellas partes del código dónde nos pueda llegar a interesar, introducimos la instrucción go to, seguida del identificador al que queremos realizar el salto.
 El resultado de la ejecución será el siguiente. 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Primero ejecuto esto 
A continuación ejecuto esto 
Por último ejecuto esto 
	A lo largo de los años, la estructura de control goto ha generado una enorme controversia dentro del mundo de la programación.
Por regla general se desaconseja su uso, ya que un uso masivo y excesivo de esta estructura puede dificultar la legibilidad del código, y puede llevar a nuestros programas a ser clasificados como “ código espagueti”
De hecho, muchos lenguajes de programación de alto nivel no incluyen un equivalente directo a esta estructura de control que todavía podemos encontrar en el lenguaje fe, debido a que es un lenguaje de bajo nivel , y está creado en una época que no es la actual.
En definitiva, el hecho  es que está estructura de control existe dentro del lenguaje de programación se , la tenemos disponible , por lo tanto , es positivo saber que la tenemos a nuestra disposición, aunque su uso a priori no sea aconsejable, para aquellas situaciones en las cuales dos pueda suponer una clara ventaja.
________________
12. Arreglos
________________
12.1. ¿Qué son las estructuras de datos?
Hasta este momento, hemos visto que es completamente frecuente y normal guardar la información que usa un programa en variables, y realizar operaciones con estas.
Las variables, por tanto, constituyen una forma inicial de guardar información, y de poder empezar a mover esta información a lo largo de un programa.
Sin embargo, hay ocasiones en las que la sencillez de las variables las hacen demasiado pequeñas como recurso, para solucionar ciertos tipos de problema.
Yo suelo decir que una variable es algo así como una caja de zapatos. Es un contenedor, que puede contener una pieza de información, pero que no puede contener demasiadas piezas de manera simultánea.
De esta forma, hay veces que, cuando necesitamos guardar múltiples piezas de información, realmente no necesitamos una caja, ni un cajón, sino un armario. Un armario, en definitiva, es una estructura donde podemos guardar múltiples piezas de información de manera simultánea.
Así que, por tanto, las estructuras de datos son formas más complejas y más estructuradas de guardar múltiples piezas de información.
Las estructuras de datos nos ofrecen métodos más complejos y más completos de almacenar múltiples piezas de información, que finalmente son necesarias por parte de los programas que desarrollamos.
12.2. Arreglos
Los arreglos son una de las formas más básicas de implementar las estructuras de datos, y se encuentran disponibles en la gran mayoría de lenguajes de programación
Permiten almacenar multitud de datos, en la gran mayoría de lenguajes de programación, permiten almacenar varias dimensiones
A continuación, se muestra un ejemplo en el que, en primer lugar, se declara un arreglo, a continuación, valores y por último, se recuperan estos valores previamente introducidos.
#include <stdio.h>

int main(int argc, char *argv[]) {
   int telefono[10];
   telefono[1] = 12345;
   telefono[2] = 23456;
   telefono[3] = 34567;
   
   printf("El segundo telefono es: %i \n",telefono[2]);
        return 0;
}
	Al realizar una llamada, es decir, una impresión a través de la consola, veremos que no solo podemos declarar los elementos que forman parte del arreglo, sino que podemos llamarlos con la misma facilidad con la cual los hemos declarado. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0036-array.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El segundo telefono es: 23456
	Como podemos observar, también conocidas como colecciones, pueden albergar diferentes piezas de información bajo un mismo nombre.
De esta forma, realmente realizan una función que podríamos con varias variables, tener que usar los diferentes
12.3. Arreglos multidimensionales
Hasta el momento, mediante el uso de las matrices de una sola dimensión, hemos podido comprobar que podemos introducir múltiples piezas de información de forma simultánea, y las podemos recuperar más adelante, lo cual evidentemente ya constituye una ventaja con respecto al uso de las variables
Sin embargo, con respecto al ejercicio de la publicación, o en definitiva, con respecto al desarrollo de cualquier ejemplo parecido al de una agenda, veremos que, realmente, en cada registro, es poco práctico únicamente poder introducir un dato, que en este caso ha sido el número de teléfono
Para poder introducir un registro de forma correcta, lo habitual es poder introducir una serie de piezas de información para cada uno de los registros. típicamente, por ejemplo, en el caso de una agenda, como mínimo, queremos saber a qué nombre de usuario pertenece ese teléfono, y ya que estamos, podríamos introducir también una dirección de correo electrónico asociado a ese usuario y a ese teléfono. estas piezas de información serán suficientes para ilustrar el concepto que se muestra a continuación, ya que evidentemente, donde introducimos 3 piezas de código podríamos introducir 300 o 3000 
Mediante el uso de dos o más dimensiones somos capaces de albergar todavía más piezas de información dentro de cada uno de los registros que guardamos en la estructura de datos
En el siguiente ejemplo se muestra un guardado en una matriz de 2 dimensiones . en primer lugar, podemos comprobar como como, utilizando dos parejas de corchetes, especificamos el número de dimensiones de la matriz, e indicamos el número de elementos que va a contener 
A continuación, empezamos a introducir cada uno de los registros, donde, como podemos comprobar, tenemos espacio tanto para albergar el nombre, el teléfono, como el correo electrónico, virtualmente entre otros tantos datos que podríamos introducir
De esta forma, las matrices bidimensionales se asemejan a hojas de cálculo, en las que encontramos filas y columnas. digamos que las filas, serían cada uno de los registros principales, correspondientes a la primera dimensión, y las columnas, serían cada uno de los registros secundarios, correspondientes en este ejemplo a la segunda dimensión
Por supuesto es posible introducir más dimensiones. cuando se trabaja con tres dimensiones ya no se puede poner el ejemplo de la hoja de cálculo, pero sin ejemplo pero sin embargo se puede introducir el ejemplo del palet lleno de cajas
Con matrices de 4 dimensiones, que son perfectamente posibles, el ejemplo, evidentemente, es más difícil de visualizar, pero no por ello menos posible o menos funcional 
#include <stdio.h>

int main(int argc, char *argv[]) {
   char* agenda[10][4];
   agenda[1][1] = "Jose Vicente";
   agenda[1][2] = "123456789";
   agenda[1][3] = "info@josevicentecarratala.com";
   
   agenda[2][1] = "Juan";
   agenda[2][2] = "987654321";
   agenda[2][3] = "juan@josevicentecarratala.com";
   
   printf("El segundo telefono es: %s \n",agenda[2][1]);
        return 0;
}
	Al ejecutar este bloque de código podremos comprobar como no solo podemos introducir dentro de memoria arreglos multidimensionales, sino que , de la misma y sencilla forma, podemos sacar por pantalla el registro correspondiente a cualquiera de las dimensiones. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0037-arraymultidimensional.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El segundo telefono es: Juan
	



________________




13. Estructuras
________________


13.1. Que son las estructuras?
Las estructuras en C, que no tienen nada que ver con las estructuras de datos tal y como las hemos presentado en los capítulos anteriores, constituyen un nivel superior de ordenación de los datos, que estaría por encima de las matrices, y por debajo de Los objetos, tal y como se entienden en el paradigma de programación orientada a objetos.
El lenguaje C, de base, no tiene soporte para el paradigma de programación orientada a objetos, al menos de forma nativa, aunque se puede conseguir mediante el uso de librerías, o, más frecuentemente, mediante el uso del lenguaje C++, que frecuentemente recibe el nombre de " C con clases "
Así pues, si bien el lenguaje se no tiene soporte para programación orientada a objetos de forma nativa, en esta publicación vamos a presentar una serie de conceptos acerca de este paradigma de programación, ya que nos ayudan a entender la utilidad de las estructuras
13.2. ¿Qué es la programación orientada a objetos?
Si nos fijamos en lo que hemos aprendido hasta el momento, podremos observar como, en un momento dado, empezamos trabajando con variables, pero más adelante, extendemos el concepto de variables mediante el uso de estructuras de datos más avanzadas, como por ejemplo, las matrices.
De esta forma, las variables nos ayudan a solucionar una serie de problemas concretos, ya que nos permiten almacenar datos de uno a uno en cada una de estas variables.
Sin embargo, en multitud de ocasiones, necesitamos guardar varios datos, varias piezas de información, dentro de la misma estructura.
Así pues, las estructuras de datos avanzadas, no son más que una solución a ese problema que frecuentemente se nos puede presentar.
De la misma forma, en cuanto a la funcionalidad, empezamos la publicación presentando cómo ejecutar instrucciones, pero en un momento dado, observamos como la programación en base a funciones suponía un avance en cuanto a nuestra metodología con como programadores, y por tanto, el uso de funciones, y el encapsulado que ello representa, nos permite realizar desarrollos más complejos, pero a la vez de una forma más mantenible.
Hasta el momento, por una parte hemos ido evolucionando en cuanto al almacenaje de información, y por otra parte, hemos ido avanzando en la ejecución de instrucciones.
La programación orientada a objetos, o lo que es lo mismo, la programación mediante clases, supone un avance un paso más allá todavía en el mismo camino y en la misma dirección en la que nosotros ya hemos empezado a avanzar.
Supone la aparición de una estructura superior llamada clase,que alguna, en una misma burbuja, en una misma cápsula, variables, que pasan a llamarse propiedades, y funciones, que pasan a llamarse métodos.
Así que, desde el plano más básico, las clases no añaden nuevas estructuras de datos ni nuevas funciones que no conozcamos, simplemente, las agregan Y las engloban dentro de una misma burbuja, por supuesto únicamente cuando esto tiene algún tipo de sentido, es decir, cuando ese conjunto de propiedades y ese conjunto de métodos tiene, contextualmente, una función y un sentido en común.
Como he comentado anteriormente, Fede no tiene soporte nativo para trabajar con clases, pero tiene un elemento parecido llamado estructura.
La estructura tiene un comportamiento muy parecido con respecto a las clases, ya que nos permite introducir una serie de variables, que pasan a llamarse propiedades, y que se aglutinan teniendo un sentido
13.3. Que son las estructuras?
Las estructuras, por tanto, no son más que grupos de datos, que comparten un significado entre sí, y que además, tienen una enumeración finita.
El clásico ejemplo de estructuras en C, lo encontramos en la declaración de un . en el espacio tridimensional.
En el momento en el que pensamos en declarar un punto en el espacio tridimensional, sabemos que ese punto, si nos ceñimos a las tres dimensiones del espacio, tiene invariablemente tres propiedades: Su valor en el eje X, en el eje Y y en el eje Z.
De esta forma, cuando declaramos una estructura, realmente lo que estamos declarando es una unidad de datos llamada., Y dentro de ella, declaramos tres propiedades, que son X, Y, Z
13.4. Declaración de estructuras
En el siguiente ejemplo vamos a materializar el caso que previsualización amos en el párrafo anterior.
Si trabajamos con el ejemplo de un . en el espacio tridimensional, veremos como una estructura se declara de la siguiente forma:
#include <stdio.h>

int main(int argc, char *argv[]) {
   struct Punto{
       int x;
       int y;
       int z;
   };
}
	Cómo podremos comprobar al ejecutar el programa, en principio todavía no tenemos ningún resultado en pantalla, ya que cuando declaramos una estructura, dicha estructura que era almacenada en la memoria, pero no tiene por qué tener ningún resultado visual en la consola o en la terminal.
En las siguientes partes del ejercicio, utilizaremos dicha estructura para crear instancias de la misma, y para poder proporcionar valores a cada una de las propiedades que hemos creado. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0038-estructura.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
	Por una parte, como hemos podido observar, declaramos el nombre de la estructura, para, a continuación, dentro de las llaves, introducir cada uno de los parámetros, es decir, cada una de las propiedades que va a tener esa estructura, cada una de ellas, con su propio tipo de datos.
De esta forma, declaramos, de forma abstracta, y todavía no usándola, la plantilla de lo que será esa estructura de datos, al igual que declaramos de forma abstracta una función antes de usarla.
Adicionalmente, podemos inicializar el valor de la estructura, con un concepto que está a caballo entre la inicialización de una variable, y un método constructor en el caso de la programación orientada a objetos.
La sintaxis quedaría de la siguiente manera:
#include <stdio.h>

int main(int argc, char *argv[]) {
   struct Punto{
       int x = 0;
       int y = 0;
       int z = 0;
   };
}
	Lo que haríamos en ese caso es preparar la estructura para que, cada vez que se cree un punto nuevo, se le asignan una serie de valores iniciales a las propiedades, antes de que nosotros podamos escribir los nuestros propios.
Si nosotros escribimos los nuestros propios, por supuesto sobreescribiran a los valores por defecto, pero si no queremos introducir valores por defecto, sabremos que al crear una estructura, por defecto ya tiene un juego de valores pre implementados.
13.5. Creación de estructuras
Una vez que ya tenemos una estructura declarada en memoria, es decir, tenemos la plantilla Del comportamiento y los elementos que va a tener esa estructura, es cuando tenemos que crear nuevos objetos a partir de ella.
Una vez más, es en este . donde la creación de estructuras a partir de la plantilla, tiene evidentemente similitudes con la programación y la creación de objetos a partir de clases.
Así que podremos crear nuevas estructuras simplemente invocando al código de la siguiente forma.
#include <stdio.h>

int main(int argc, char *argv[]) {
   struct Punto{
       int x;
       int y;
       int z;
   };
   struct . punto1;
   punto1.x = 100;
   punto1.y = 200;
   punto1.z = 300;
   printf("La propiedad x es: %d \n",punto1.x);
}
	Al ejecutar este código en la terminal o en la consola, podremos comprobar cómo podemos acceder a las propiedades de las estructuras de una forma mucho más clara, utilizando su nombre en lugar de un índice numérico, comparativamente a cómo lo haríamos utilizando los arreglos. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0039-estructurapunto.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
La propiedad x es: 100
	La creación de propiedades de tipo cadena tiene una particularidad con respecto a la escritura de las propiedades de tipo numérico.
Para el trabajo con propiedad de ese tipo numérico, simplemente tenemos que aplicar un operador de igualdad para asignar valor a la propiedad de la estructura.
Sin embargo, si lo que queremos es asignar propiedades en formato de cadena Alfanumérica, tendremos que usar la siguiente función para conseguir el pase correcto de los parámetros:
#include <stdio.h>

int main(int argc, char *argv[]) {
   struct RegistroAgenda{
       char nombre[50];
       char telefono[50];
       char email[50];
   };
   
}
	Al introducir cadenas de caracteres como arreglos, en este ejemplo con una longitud máxima de 50 caracteres, seremos capaces de que nuestra estructuras almacén en cadenas alfanuméricas, para guardar cualquier pieza de información que nos pueda interesar 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0040-estructuracadena.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out
	Como podremos comprobar, simplemente utilizando una de las funciones de la librería de tratamiento de cadenas, podremos no aplicar una igualdad, pero sí realizar una copia de la cadena dentro del valor de la propiedad.
Si seguimos el siguiente ejemplo conjunto:
#include <stdio.h>
#include <string.h>
int main(int argc, char *argv[]) {
   struct RegistroAgenda{
       char nombre[50];
       char telefono[50];
       char email[50];
   };
   // Primer registro
   struct RegistroAgenda registro1;
   strcpy(registro1.nombre,"Jose Vicente");
   strcpy(registro1.telefono,"12345678");
   strcpy(registro1.email,"info@josevicentecarratala.com");
   // Segundo registro
   struct RegistroAgenda registro2;
   strcpy(registro2.nombre,"Juan");
   strcpy(registro2.telefono,"87654321");
   strcpy(registro2.email,"juan@josevicentecarratala.com");
   // Devolvemos:
   printf("El nombre del primer registro es: %s \n",registro1.nombre);
   printf("El telefono del segundo registro es: %s \n",registro2.telefono);
}
	

Al ejecutar el código de este ejercicio, podemos comprobar como, en la primera parte, hemos declarado una estructura que va a contener un nombre, un teléfono, y un correo electrónico. dicha estructura es nada más que una plantilla, y todavía no corresponde a ningún registro de la agenda en concreto.
struct RegistroAgenda{
       char nombre[50];
       char telefono[50];
       char email[50];
   };
	A continuación, en la siguiente parte , creamos un primer registro, mediante el cual especificamos que vamos a utilizar una estructura, especificamos el tipo de dato, e introducimos el nombre de la instancia concreta de esa estructura.
struct RegistroAgenda registro1;
	En las siguientes líneas utilizamos la función de copia de cadenas para poder copiar un valor dentro  de la propiedad de esa estructura
strcpy(registro1.nombre,"Jose Vicente");
	Por último, una vez que hemos introducido todos los valores, en la última parte del programa podremos comprobar como, de la misma forma que hemos sido capaces de escribir contenido dentro de la estructura, ponemos también recuperar los valores.
printf("El nombre del primer registro es: %s \n",registro1.nombre);
	El resultado de ejecutar este programa en la consola o en la terminal será el siguiente 
​​MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0041-estructuraagenda.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El nombre del primer registro es: Jose Vicente 
El telefono del segundo registro es: 87654321
	Podremos comprobar cómo, a partir de una estructura, asignaremos tanto valores numéricos como valores alfanuméricos sin ningún problema dentro del mismo proyecto.
13.6. Estructuras dentro de matrices


#include <stdio.h>
#include <string.h>
int main(int argc, char *argv[]) {
   struct RegistroAgenda{
       char nombre[50];
       char telefono[50];
       char email[50];
   };
   
   // Primer registro
   struct RegistroAgenda registros[1];
   strcpy(registros[1].nombre,"Jose Vicente");
   strcpy(registros[1].telefono,"12345678");
   strcpy(registros[1].email,"info@josevicentecarratala.com");
   
   
   printf("El registro es: %s",registros[1].nombre);
}
	Al ejecutar este ejercicio podremos comprobar cómo somos capaces de introducir información en cada uno de los miembros de la estructura, e imprimirlos por pantalla, habiendo definido una instancia de una estructura dentro de un arreglo de datos 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0042-estructurasmatrices.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Abort trap: 6
	13.7. Ejercicio del curso
A continuación, aplicamos el contenido didáctico de esta unidad, al ejercicio práctico que estamos desarrollando en el curso
Queda patente cómo el uso de estructuras tiene claras ventajas con respecto, por ejemplo, si nos fijamos en la unidad anterior, al uso de matrices de múltiples dimensiones
Por ejemplo, en el caso de las matrices de múltiples dimensiones, es perfectamente entendible que cada uno de los registros tenga una entidad numérica, el registro número 1, el registro número 2, el registro número 3 de la agenda telefónica
Pero si nos fijamos en el ejercicio anterior, en la segunda dimensión, teníamos un carácter uno para el nombre, dos para el teléfono, y tres para el correo electrónico . esto es perfectamente usable y funcional, pero sin embargo, finalmente somos nosotros quién le damos sentido a la segunda dimensión
Con las estructuras, en cambio, para con el ejemplo del curso, tenemos exactamente el mismo almacenaje de datos, pero lo hacemos de un modo mucho más entendible, tanto desde el almacenaje de los datos, como también desde la recuperación de los mismos, ya que no estamos llamando a un índice anónimo de una matriz, sino que estamos llamando a una propiedad de una forma mucho más clara y transparente
Dicho esto, la consecuencia no es necesariamente que las estructuras siempre sean mejores con respecto al uso de matrices multidimensionales, simplemente es una herramienta más que el lenguaje de programación pone a nuestra disposición 
📂proyectodelcurso/   📄main.c
	/* Programa agenda
por Jose Vicente Carratala */
#include <stdio.h>
#include <string.h>
#define NOMBREPROGRAMA "Programa agenda"
#define VERSION "1.0"
#define AUTOR "Jose Vicente Carratala"

int main(int argc, char *argv[]) {
   
   struct RegistroAgenda{
       char nombre[50];
       char telefono[50];
       char email[50];
   };
   // Primer registro
   struct RegistroAgenda agenda[100];
   strcpy(agenda[1].nombre,"Jose Vicente");
   strcpy(agenda[1].telefono,"12345678");
   strcpy(agenda[1].email,"info@josevicentecarratala.com");
   
   // Segundo registro
   strcpy(agenda[2].nombre,"Juan");
   strcpy(agenda[2].telefono,"53254");
   strcpy(agenda[2].email,"juan@josevicentecarratala.com");
   // Tercer registro
   strcpy(agenda[3].nombre,"Jaime");
   strcpy(agenda[3].telefono,"64566");
   strcpy(agenda[3].email,"jaime@josevicentecarratala.com");
   
   // Mensaje de bienvenida
        printf("%s v%s \n",NOMBREPROGRAMA,VERSION);
        printf("%s \n",AUTOR);
        printf("\t 1 - Listado de registros \n");
        printf("\t 2 - Introducir un registro \n");
        printf("\t 3 - Eliminar un registro \n");
        printf("\t 4 - Buscar un registro \n");
        printf("\t 5 - Actualizar un registro \n");
        printf("Tu opcion: ");
        char opcion = getchar();
        printf("La opción que has seleccionado es: %c \n",opcion);
        switch(opcion){
            case '1':
                printf("Vamos a listar los registros \n");
                printf("Registro: %s %s %s \n",agenda[1].nombre,agenda[1].telefono,agenda[1].email);
                printf("Registro: %s %s %s \n",agenda[2].nombre,agenda[2].telefono,agenda[2].email);
                printf("Registro: %s %s %s \n",agenda[3].nombre,agenda[3].telefono,agenda[3].email);
                break;
       case '2':
                printf("Vamos a introducir un registro");
                break;
       case '3':
                printf("Vamos a eliminar un registro");
                break;
       case '4':
                printf("Vamos a buscar un registro");
                break;
            case '5':
                printf("Vamos a actualizar un registro");
                break;
       default:
           printf("La opción que has introducido no es válida");
           break;
        }
        
        return 0;
}
	Al ejecutar este ejercicio vamos a poder comprobar, en la terminal o en la consola, como, en el caso de que invoquemos a la primera opción del menú que se nos presenta, se imprime en pantalla el contenido de la estructura que hemos guardado previamente.
Evidentemente, en las siguientes fases del proyecto, el contenido de la estructura no vendrá indicado de forma estática como ocurre en este momento, sino que será el usuario el que podrá introducir tantas instancias de la estructura como sean necesarias. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0043-agenda.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Programa agenda v1.0 
Jose Vicente Carratala 
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
Tu opcion: 1
La opción que has seleccionado es: 1 
Vamos a listar los registros 
Registro: Jose Vicente 12345678 info@josevicentecarratala.com 
Registro: Juan 53254 juan@josevicentecarratala.com 
Registro: Jaime 64566 jaime@josevicentecarratala.com 
	13.8. Ejercicio del curso
En la versión anterior del ejercicio en la opción de listado de registros, teníamos una forma completamente ineficiente de obtener de vuelta los registros de la estructura que guarda la agenda
Si nos fijamos, en el desarrollo anterior del ejercicio, cada vez que realizamos un listado, lo que conseguimos era listar uno a uno, de forma repetitiva, los elementos de la agenda. Esto, evidentemente, es terriblemente ineficiente. en el desarrollo de programas informáticos, siempre que vemos que una estructura se repite varias veces, nos vemos repetirla a mano, sino que deberíamos encontrar una forma automatizada de realizar esa repetición
Esto es exactamente lo que nos proporcionan las estructuras de control de bucle, la posibilidad de que el programa repita automáticamente por nosotros una tarea que, hasta el momento, habíamos tenido que repetir de manera completamente manual
Así que en esta aplicación de la unidad didáctica al ejercicios del curso, como podemos comprobar, se ha utilizado una estructura de control for para automatizar la devolución de registros en el listado en pantalla
De esta forma, ahora no importaría en la teoría que el listado de registros tuviera uno, dos, tres, o 3000 componentes, porque simplemente tendríamos que indicar una nueva finalización a la estructura de control for 
📂proyectodelcurso/   📄main.c
	/* Programa agenda
por Jose Vicente Carratala */
#include <stdio.h>
#include <string.h>
#define NOMBREPROGRAMA "Programa agenda"
#define VERSION "1.0"
#define AUTOR "Jose Vicente Carratala"

int main(int argc, char *argv[]) {
        struct RegistroAgenda{
       char nombre[50];
       char telefono[50];
       char email[50];
   };
   // Primer registro
   struct RegistroAgenda agenda[100];
   strcpy(agenda[1].nombre,"Jose Vicente");
   strcpy(agenda[1].telefono,"12345678");
   strcpy(agenda[1].email,"info@josevicentecarratala.com");
   
   // Segundo registro
   strcpy(agenda[2].nombre,"Juan");
   strcpy(agenda[2].telefono,"53254");
   strcpy(agenda[2].email,"juan@josevicentecarratala.com");
   // Tercer registro
   strcpy(agenda[3].nombre,"Jaime");
   strcpy(agenda[3].telefono,"64566");
   strcpy(agenda[3].email,"jaime@josevicentecarratala.com");
        
   // Mensaje de bienvenida
        printf("%s v%s \n",NOMBREPROGRAMA,VERSION);
        printf("%s \n",AUTOR);
        printf("\t 1 - Listado de registros \n");
        printf("\t 2 - Introducir un registro \n");
        printf("\t 3 - Eliminar un registro \n");
        printf("\t 4 - Buscar un registro \n");
        printf("\t 5 - Actualizar un registro \n");
        printf("Tu opcion: ");
        char opcion = getchar();
        printf("La opción que has seleccionado es: %c \n",opcion);
        switch(opcion){
            case '1':
                for(int i = 1; i<=3;i++){
                    printf("Registro: %s %s %s \n",agenda[i].nombre,agenda[i].telefono,agenda[i].email);
                }
                break;
       case '2':
                printf("Vamos a introducir un registro");
                break;
       case '3':
                printf("Vamos a eliminar un registro");
                break;
       case '4':
                printf("Vamos a buscar un registro");
                break;
            case '5':
                printf("Vamos a actualizar un registro");
                break;
       default:
           printf("La opción que has introducido no es válida");
           break;
        }
        
        return 0;
}


	Al ejecutar este ejercicio, comprobamos cómo la estructura de bucle de tipo Ford nos permite realizar una iteración en los tres primeros registros que contiene la agenda, para no tener que imprimir de forma manual cada uno de estos tres registros, sino que los podemos obtener de una forma automatizada.
Parece que no hayamos conseguido mucho avance, desde el . de vista en el que todavía hemos tenido que escribir literalmente tres líneas de código, pero tengamos en cuenta que esta misma solución nos serviría para imprimir 30, 300, o 3000 entradas de una agenda, en cuyo caso sí que percibimos una evidente ventaja al utilizar estructuras de control como la que hemos utilizado en este ejercicio 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0053-agenda.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Programa agenda v1.0 
Jose Vicente Carratala 
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
Tu opcion: 1
La opción que has seleccionado es: 1 
Registro: Jose Vicente 12345678 info@josevicentecarratala.com 
Registro: Juan 53254 juan@josevicentecarratala.com 
Registro: Jaime 64566 jaime@josevicentecarratala.com 
MacBook-Pro-de-Jose:cursodec josevicente$ 

	



________________




14. Funciones
________________


14.1. ¿Qué son las funciones?
Las funciones existen para cubrir varias necesidades que el programador acaba teniendo en su día a día.
De hecho, en nuestro caso, tal y como llevamos ahora mismo el ejercicio del curso, veremos que el uso de funciones no supone claras ventajas para mantener nuestro código entendible y mantenible.
podemos incluso concebir las funciones como pequeños programas dentro de un programa más grande, ya que son bloques de código encapsulados que aceptan una entrada, realizar un cálculo, y devuelven un resultado.
La diferencia es que, si bien el programa original acepta una entrada usualmente proporcionada por el ser humano, y ofrece una salida también usualmente al ser humano, las funciones son pequeños programas que existen dentro del programa principal, y es por esto que, muy generalmente, aceptan datos no del ser humano sino del programa principal, y devuelven datos no al ser humano, sino al programa principal.
Por tanto, el concepto principal cuando hablamos de funciones es el de la encapsulación. Es decir, introducir una pieza del código que tenga sentido como bloque, y aislarla del resto del código.
Esto, en un momento dado, puede tener claras y evidentes ventajas.
En primer lugar, es muy común, durante el desarrollo de un programa informático, que haya porciones de código que se repitan.
Las funciones nos proporcionan una posibilidad fantástica de aislar estas porciones en una función, y simplemente llamar a la función tantas veces como sea necesario, centralizando el código, y evitando repeticiones innecesarias que dificultan enormemente la mantenía peligrar del código.
De esta forma, y como podemos imaginar, lo principal que debemos aprender con respecto a las funciones es, en primer lugar, como declararlas, y en segundo lugar, cómo usarlas.
Así que, vamos a poner un primer ejemplo, en el que tendríamos, por ejemplo, un programa que realiza la siguiente función:
#include <stdio.h>

int main(int argc, char *argv[]) {
   printf("Hola, Jose Vicente \n");
        return 0;
}
	Este código no contiene funciones, o mejor dicho, sí que contiene una función principal, pero qué es obligatoria, ya que es el . de entrada de ejecución de nuestro programa informático. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0054-funcionmain.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hola, Jose Vicente 
	De hecho todo el tiempo hemos estado trabajando con una función principal, una función que se encarga de establecer el . de entrada del programa, así que, en el fondo, el uso de funciones no no se es extraño en absoluto, ya que, sin quererlo, las llevamos usando desde el principio de nuestra andadura con este lenguaje de programación.
14.2. Declaración de funciones
Ahora, lo importante, es que en un momento dado, podemos declarar nuevas funciones.
Dependiendo del lenguaje de programación, podemos declarar nuevas funciones antes o después de la función principal.
Eres de caso, lo que haremos, por compatibilidad, es declarar nuestras funciones antes de la función principal, para que cuando se profesen, el sistema sea consciente primero de nuestras funciones, y luego desuso
Así que el código anterior se transforma en el siguiente código.
#include <stdio.h>
void saluda(){
   printf("Hola, Jose Vicente \n");
}
int main(int argc, char *argv[]) {
   
        return 0;
}
	Al ejecutar este ejercicio, todavía no tenemos ningún resultado, ya que hemos declarado la función en la memoria, pero no hemos realizado ninguna llamada a ejecutar esa función, en ninguna parte del programa, todavía. realizaremos ese paso más adelante en las siguientes iteraciones de este ejercicio 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0055-funcion.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out
	Como podemos observar, al declarar una función, en primer lugar, declaramos el tipo de dato te va a devolver la función.
A continuación, establecemos el nombre del programa, siguiendo las reglas de estilo que hemos visto anteriormente.
Lo siguiente que podemos observar, es que las funciones, mediante la aparición de unos paréntesis, pueden aceptar parámetros. Sin embargo, para este primer ejemplo, vamos a crear una función sin necesidad de poner parámetros.
Deberemos tener en cuenta, eso sí, que aunque la función no acepte parámetros, es obligatorio poner los paréntesis, aunque finalmente se queden vacíos.
Por último, encerrado entre llaves, encontramos el código que se va a ejecutar en el momento en el que se llame a la función.
Así que, finalmente, nuestro código quedaría de la siguiente forma:
#include <stdio.h>
void saluda(){
   printf("Hola, Jose Vicente \n");
}
int main(int argc, char *argv[]) {
   
        return 0;
}
	Sin embargo, si ejecutamos el código que he descrito anteriormente, podremos comprobar que el programa no hace nada.
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0056-funcion2.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
	Este es un concepto muy importante que debemos entender del uso del concepto de encapsulación, y en este caso, del uso de funciones.
En el momento en el que yo creo una cápsula, es decir, en el momento en el que creamos una función, eso no implica que la función se esté ejecutando.
Si nos fijamos, ocurre exactamente lo mismo que cuando declaramos variables.
El hecho de que yo declare una variable, no implica, en absoluto, que yo estoy usando esa variable. Con las funciones ocurre exactamente lo mismo, que yo esté declarando una función no implica, en absoluto, que esté ejecutando esa función.
Lo único que estoy haciendo es introduciendo esa función en la memoria, y preparando el programa para cuando yo la llame, pero el caso es que, de momento, no he llamado a la función
14.3. Uso de funciones
Una vez que hemos definido una función, a continuación, probablemente querremos llamarla. Mediante la invocación de una función, ejecutamos el código que está contiene. Así que, por ejemplo, en la función principal, vamos a escribir el siguiente código:
#include <stdio.h>
void saluda(){
   printf("Hola, Jose Vicente \n");
}
int main(int argc, char *argv[]) {
   saluda();
        return 0;
}
	Ahora sí, al ejecutar este ejercicio, veremos que no solo hemos declarado la función en la memoria, sino que también la estamos utilizando al invocar la desde la función principal, con lo cual, en la terminal o en la consuela, obtendremos el resultado de llamar a la función 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0057-usodelafuncion.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hola, Jose Vicente 
	De esta forma, si ahora ejecutamos el programa, cómo podremos comprobar, obtenemos de vuelta la ejecución del código que contiene la función.
De esta forma, hemos visto cómo declarar en primer lugar una función, y a continuación, utilizarlo
14.4. Funciones con parámetros
Lo que hemos visto hasta el momento en cuanto al trabajo con funciones, ya es útil desde el . de vista en que nos permite aislar porciones de código, y eventualmente, en el caso de que esa porción se repita, nos permite simplificar y reducir la repetición, mediante la definición invocación de funciones.
Sin embargo, los parámetros nos permiten aumentar todavía más la potencia de las funciones mediante la personalización de su función.
La función que hemos declarado anteriormente tiene un único comportamiento es decir, tiene una única posibilidad de ejecución.
Así que, si en lugar de querer una función que me salude a mí, quiero una función y que salude a cualquier otro nombre de persona, tendría que escribir tantas funciones como nombres de personas pudiera imaginar.
Como podemos imaginarnos, esto sería terriblemente ineficiente para lo que son los mecanismos y las estructuras de un lenguaje de programación.
Para esto precisamente existen los parámetros de las funciones. Los parámetros nos permiten personalizar y adaptar el comportamiento de una función, para que se comporte de tantas maneras como necesitemos.
Así que, en el ejemplo anterior, voy a introducir un parámetro dentro del paréntesis, al que llamaré nombre.
El código anterior, queda de la siguiente manera:
#include <stdio.h>
void saluda(char* nombre){
   printf("Hola, %s \n",nombre);
}
int main(int argc, char *argv[]) {
   saluda();
        return 0;
}
	Si ahora intento ejecutar el código en la función principal de la misma forma que lo había hecho hasta el momento, ahora obtendré un error de vuelta, producido evidentemente por el hecho de que yo ahora estoy prometiendo que la función afecta un parámetro, Pero sin embargo, cuando la invoco, no le estoy pasando este parámetro.
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0058-funcionesparametros.c 
0058-funcionesparametros.c:6:12: error: too few arguments to function call,
     single argument 'nombre' was not specified
   saluda();
   ~~~~~~ ^
0058-funcionesparametros.c:2:1: note: 'saluda' declared here
void saluda(char* nombre){
^
1 error generated.
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Lo que ocurre en ese momento depende en gran medida de lo permisivo que sea el lenguaje de programación, pero en la mayoría de los casos, el resultado es un error debido a que no estoy invocando la función de la forma correcta, es decir, no la estoy invocando con las mismas reglas que la he definido.
Si ahora introduzco un parámetro de los paréntesis, la función vuelve a funcionar correctamente.
#include <stdio.h>
void saluda(char* nombre){
   printf("Hola, %s \n",nombre);
}
int main(int argc, char *argv[]) {
   saluda("Jose Vicente");
        return 0;
}
	Si ahora ejecutamos el programa, podremos comprobar como en esta ocasión funciona correctamente, ya que la declaración de la función espera que se le pase un parámetro , qué es el nombre, y en la llamada a la función, dentro de la función principal, efectivamente se le está pasando este parámetro. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0059-funcionparametro.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hola, Jose Vicente 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Pero sobre todo, lo más importante, es que puedo llamar varias veces a la función, y en cada una de las ejecuciones, puedo llamar a un parámetro diferente.
Si ahora, dentro de los paréntesis, introducimos diferentes nombres de persona, comprobaremos que tenemos una misma función que puede tener múltiples comportamientos, todo ello basado en los parámetros que tiene la función
14.5. Funciones con múltiples parámetros
Por supuesto, una función no solo puede aceptar un parámetro, sino que generalmente acepta varios de ellos.
En este ejemplo, voy a extender la función para introducir un segundo parámetro, no Merico, que sea la edad.
#include <stdio.h>
void saluda(char* nombre, int edad){
   printf("Hola, %s, tienes %i años \n",nombre,edad);
}
int main(int argc, char *argv[]) {
   saluda("Jose Vicente",40);
        return 0;
}
	Al ejecutar este ejercicio podremos comprobar como no solo somos capaces de pasar un parámetro a la función, sino que podemos pasar un primer parámetro consistente en el nombre, y un segundo parámetro consistente en la edad.
En la consola o en la terminal veremos cómo aparece la información correctamente ejecutada interpretada por la función 
​​MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0060-funcionesmultiplesparametros.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Hola, Jose Vicente, tienes 40 años 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	Como habremos observado anteriormente, lo único importante al declarar parámetros de funciones, es que exista una coincidencia absoluta entre el nombre del parámetro cuando lo declaramos en los paréntesis, y el nombre del parámetro cuando lo utilizamos dentro del código.
Así que, de esta manera, si introduzco dos parámetros dentro de los paréntesis, y los uso correctamente dentro del código, podremos observar, evidentemente llamando correctamente a la función dentro del método print principal, como, sin ningún problema, la función ahora puede trabajar con dos parámetros


14.6. El ámbito de las variables:
Hay un concepto de vital importancia durante el desarrollo de aplicaciones, qué consiste en controlar el ámbito de las variables. el ámbito hace referencia al contexto en el que esas variables existen
La regla en cuanto al ámbito de las variables es realmente sencilla. Si una variable se declara dentro de una función,  la variable sólo existe, y por tanto solo puede usarse, dentro de esa función.
Sí intentamos llamar a esa variable fuera de la función, encontraremos que el programa no reconoce el valor de esa variable, como en el ejemplo siguiente
Sin embargo, si esa variable ha sido declarada fuera de la función, y por tanto, con respecto al lenguaje de programación que estamos cubriendo en esta publicación, ha sido declarada fuera de todas las funciones, pasa a conocerse con el nombre de variable global, y por tanto es una variable que existe, y por tanto se comparte entre las diferentes funciones que comparten un programa
En definitiva, el conocimiento de la existencia del ámbito de las variables nos permite jugar, ya que hay casos en los que nos interesa que una variable solo exista, sólo tenga sentido, solo se pueda modificar desde dentro de una función, y hay otras muchas veces en las que nos interesa que una variable pueda ser modificada a lo largo de las diferentes funciones de un programa 
14.7. Ejercicio del curso
El código fuente de nuestro programa se va alargando, y en cierta forma, se va complicando
Es por esto que empezamos a aislar el contenido y la funcionalidad de cada una de las opciones que se le ofrece al usuario, en una función diferente . en esta fase del ejercicio, antes de la función principal, declaramos una serie de funciones, donde cada una de ellas corresponde a cada una de las opciones que se le proporcionan al usuario. incluso definimos una función que corresponde al propio menú del programa
Una vez que estas funciones han sido declaradas en la parte inicial del programa, esto es, recomendablemente siempre antes de la función principal, a continuación, extraemos el código de cada una de las opciones del usuario, y lo introducimos dentro de cada una de las funciones que hemos creado anteriormente
Por último, en la función de menú principal, en cada una de las opciones, reemplazamos el código original con la llamada a la función correspondiente. al realizar esta acción, podremos comprobar como el código resultante es, de momento, igualmente grande, pero desde luego mucho más legible de lo que era anteriormente
El último paso, en este caso, consiste simplemente en realizar una llamada a la función de menú principal, desde la propia función principal del programa 




📂proyectodelcurso/   📄main.c
	/* Programa agenda
por Jose Vicente Carratala */
#include <stdio.h>
#include <string.h>
#define NOMBREPROGRAMA "Programa agenda"
#define VERSION "1.0"
#define AUTOR "Jose Vicente Carratala"

        struct RegistroAgenda{
       char nombre[50];
       char telefono[50];
       char email[50];
   };
   
   struct RegistroAgenda agenda[100];
void listadoRegistros(){
   for(int i = 1; i<=3;i++){
       printf("Registro: %s %s %s \n",agenda[i].nombre,agenda[i].telefono,agenda[i].email);
   }
}
void introducirRegistro(){
   printf("Vamos a introducir un registro");
}
void eliminarRegistro(){
   printf("Vamos a eliminar un registro");
}
void buscarRegistro(){
   printf("Vamos a buscar un registro");
}
void actualizarRegistro(){
   printf("Vamos a actualizar un registro");
}
void menuPrincipal(){
    // Mensaje de bienvenida
        printf("%s v%s \n",NOMBREPROGRAMA,VERSION);
        printf("%s \n",AUTOR);
        printf("\t 1 - Listado de registros \n");
        printf("\t 2 - Introducir un registro \n");
        printf("\t 3 - Eliminar un registro \n");
        printf("\t 4 - Buscar un registro \n");
        printf("\t 5 - Actualizar un registro \n");
        printf("Tu opcion: ");
        char opcion = getchar();
        printf("La opción que has seleccionado es: %c \n",opcion);
        switch(opcion){
            case '1':
                listadoRegistros();
                break;
       case '2':
                introducirRegistro();
                break;
       case '3':
                eliminarRegistro();
                break;
       case '4':
                buscarRegistro();
                break;
            case '5':
                actualizarRegistro();
                break;
       default:
           printf("La opción que has introducido no es válida");
           break;
        }
}
int main(int argc, char *argv[]) {

   // Primer registro
   
   strcpy(agenda[1].nombre,"Jose Vicente");
   strcpy(agenda[1].telefono,"12345678");
   strcpy(agenda[1].email,"info@josevicentecarratala.com");
   
   // Segundo registro
   strcpy(agenda[2].nombre,"Juan");
   strcpy(agenda[2].telefono,"53254");
   strcpy(agenda[2].email,"juan@josevicentecarratala.com");
   // Tercer registro
   strcpy(agenda[3].nombre,"Jaime");
   strcpy(agenda[3].telefono,"64566");
   strcpy(agenda[3].email,"jaime@josevicentecarratala.com");
        
  menuPrincipal();
        
        return 0;
}
	Aunque el código del programa se va alargando, lo cierto es que todavía resulta claro, en el sentido de que podemos entender fácilmente que las opciones, de momento vacías, que hemos declarado antes de la función principal, son las funciones que se van a encargar de realizar cada una de las tareas que hemos introducido en el menú principal. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0062-agenda.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Programa agenda v1.0 
Jose Vicente Carratala 
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
Tu opcion: 1
La opción que has seleccionado es: 1 
Registro: Jose Vicente 12345678 info@josevicentecarratala.com 
Registro: Juan 53254 juan@josevicentecarratala.com 
Registro: Jaime 64566 jaime@josevicentecarratala.com 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	14.8. Externalización del contenido.
En el desarrollo de aplicaciones informáticas suele aplicarse la regla de " divide y vencerás " con bastante éxito.
Aunque existen ocasiones en las que está justificado mantener un código monolítico, una gran pieza de código contenida en un único archivo o en un pequeño conjunto de archivos, por regla general, la recomendación es justo la contraria:
Mantener el código separado en un número razonable y justificado de archivos independientes, para ver esta manera, Mantener el código modular izado, independiente, y más fácilmente mantenible.
Todo el código que hemos desarrollado hasta ahora, está dentro de un único archivo, en el caso tanto de los ejercicios individuales, como en el caso del proyecto continuo que vamos realizando unidad a unidad.
A continuación, se muestra un ejemplo en el que partimos del siguiente código:
// main.c
#include <stdio.h>
int calculadoraSuma(int operando1, int operando2){
   return(operando1 + operando2);
}
int main(int argc, char *argv[]) {
   printf("El resultado es: %i \n",calculadoraSuma(5,4));
        return 0;
}
	Como podemos ver, tenemos una función principal, y también tenemos una función que antecede a la función principal, que cumple un cometido concreto, sea cual sea.
Una estrategia que podemos cumplir es la de externalizar esa función no principal en un archivo que puede estar adherido al archivo inicial, o puede estar incluido dentro de una carpeta.
Para este ejemplo, dentro de la estructura de directorios, dentro de la misma carpeta donde se encuentra el proyecto actual, donde encontramos el código del archivo principal.
Dentro de esta carpeta, creamos una nueva su carpeta, y le ponemos el nombre que queramos, siguiendo las mismas reglas de estilo que estamos utilizando a lo largo de todo el desarrollo.
Por ejemplo, la carpeta puede recibir el nombre de " librerías "
Dentro de esta carpeta, creamos un nuevo archivo con la extensión C, donde introduciremos nuestro código. Es decir, cortamos el código de la función no principal desde el archivo mail. C, hasta el archivo que acabamos de crear dentro de la carpeta librerías. Por ejemplo, le ponemos el nombre saludar. C, y pegamos dentro de él el contenido cortado, es decir, la función.
📂proyectodelcurso/  📂lib/ 📄calculadoraSuma.c
	// lib/calculadoraSuma.c
int calculadoraSuma(int operando1, int operando2){
   return(operando1 + operando2);
}
	Debemos tener cuidado porque, si no estamos trabajando en un entorno de desarrollo integrado, muy probablemente, al haber movido la función a otro archivo con respecto al archivo original, la función principal ya no es capaz de ver dónde está la declaración de la función de saludo.
Esto quiere decir que, si ahora ejecutamos el programa principal, dará error, porque se está invocando a la función, pero no se sabe dónde se está declarando la función.
Para conseguir este objetivo, lo que tenemos que hacer es usar las cabeceras para realizar una importación.
Mediante la siguiente importación:
📂proyectodelcurso/  📄main.c
	// main.c
#include <stdio.h>
#include "lib/calculadoraSuma.c"
int main(int argc, char *argv[]) {
   printf("El resultado es: %i \n",calculadoraSuma(5,4));
        return 0;
}
	Estamos indicando al programa principal que tiene que tomar el código de la carpeta de librerías, y por tanto, tiene que ser consciente de la declaración de la función.
De esta full de esta forma, ahora, si ejecutamos el código, podremos comprobar cómo vuelve a funcionar correctamente, ya que, aunque la función no está físicamente declarada dentro del archivo principal, sí que estás siendo incluida a través de la cabecera, con lo cual, a efectos prácticos de la compilación, es como si estuviera dentro del archivo original del proyecto.
Como nos podemos imaginar, este proceso es repetible tantas veces como sea necesario, para mantener el código lo más modular posible, y por tanto facilitar su comprensión y su mantenimiento.
14.9. Ejercicio del curso:
Aplicamos este valioso conocimiento para mejorar la mantenibilidad del código que hasta el momento hemos desarrollado
Nuestro proyecto de agenda, en la iteración anterior, se ha convertido en un programa ciertamente largo. esto suele suceder con mucha frecuencia a medida que vamos desarrollando, diría yo, cualquier tipo de programa . llega un momento, especialmente cuando estamos usando programación estructurada, en el que el código fuente de nuestra aplicación tiene un número par de líneas que le empieza a resultar incómodo ir de una sección a otra del código, para implementar cambios, mejoras, o nuevas funcionalidades
Cuando este momento llega, es cuando debemos plantearnos implementar alguna metodología para conseguir que el proyecto sea más fácilmente manipulable
Así que en este caso, lo que hacemos es externalizar cada una de las funciones en un archivo diferente, que más adelante será incluido dentro del programa principal
De esta forma, en primer lugar, creamos una carpeta en la que introducimos nuevos archivos con la extensión c. aunque no es obligatorio, evidentemente, por claridad, cada archivo recibe el nombre de la función que contiene. y cada archivo contiene únicamente, para este ejemplo, una función, aunque debemos tener en cuenta que esto, para este ejercicio, es más una recomendación que una obligación
Por supuesto, a medida que vamos poniendo el código fuente de las funciones en cada uno de los archivos externos, también lo quitamos del programa principal, para que no esté por duplicado
Por último, en la parte inicial del programa principal, dentro del preprocesador, incluimos todos los archivos de las funciones, para que más adelante puedan ser utilizadas 
 📂proyectodelcurso/   📄main.c
	// main.c
/* Programa agenda
por Jose Vicente Carratala */
#define NOMBREPROGRAMA "Programa agenda"
#define VERSION "1.0"
#define AUTOR "Jose Vicente Carratala"
#include <stdio.h>
#include <string.h>
#include "libAgenda/datos.c"
#include "libAgenda/listadoRegistros.c"
#include "libAgenda/introducirRegistro.c"
#include "libAgenda/eliminarRegistro.c"
#include "libAgenda/buscarRegistro.c"
#include "libAgenda/actualizarRegistro.c"
#include "libAgenda/menuPrincipal.c"

int main(int argc, char *argv[]) {

   // Primer registro
   
   strcpy(agenda[1].nombre,"Jose Vicente");
   strcpy(agenda[1].telefono,"12345678");
   strcpy(agenda[1].email,"info@josevicentecarratala.com");
   
   // Segundo registro
   strcpy(agenda[2].nombre,"Juan");
   strcpy(agenda[2].telefono,"53254");
   strcpy(agenda[2].email,"juan@josevicentecarratala.com");
   // Tercer registro
   strcpy(agenda[3].nombre,"Jaime");
   strcpy(agenda[3].telefono,"64566");
   strcpy(agenda[3].email,"jaime@josevicentecarratala.com");
        
  menuPrincipal();
        
        return 0;
}
	A continuación encontramos el archivo que se encarga específicamente de incluir un registro nuevo, que, por el momento, únicamente tiene un comando de impresión por pantalla 
📂proyectodelcurso/  📂libAgenda/ 📄introducirRegistro.c
	// libAgenda/introducirRegistro.c
void introducirRegistro(){
   printf("Vamos a introducir un registro");
}
	Lo mismo ocurre con el archivo ver actualización de registros, de momento, únicamente tiene una impresión por pantalla para anunciar la acción que va a realizar. 
📂proyectodelcurso/  📂libAgenda/ 📄actualizarRegistro.c
	// libAgenda/actualizarRegistro.c
void actualizarRegistro(){
   printf("Vamos a actualizar un registro");
}
	En este archivo guardaremos, por una parte, la definición de la estructura correspondiente a cada uno de los registros de la agenda, con sus tres propiedades, que son el nombre, el teléfono, y el correo electrónico. a continuación, definiremos 100 registros vacíos para poder utilizarlos durante la ejecución del programa. es decir, tenemos 100 huecos en nuestra lista de contactos para poder utilizar. 
📂proyectodelcurso/  📂libAgenda/ 📄datos.c
	// libAgenda/datos.c
struct RegistroAgenda{
       char nombre[50];
       char telefono[50];
       char email[50];
   };
   
   struct RegistroAgenda agenda[100];
	El listado de registros, encontraremos el bucle for que se encarga de recorrer uno a uno los registros de la agenda, y sacarlos a través de la pantalla. 
📂proyectodelcurso/  📂libAgenda/ 📄listadoRegistros.c
	// libAgenda/listadoRegistros.c
void listadoRegistros(){
   for(int i = 1; i<=3;i++){
       printf("Registro: %s %s %s \n",agenda[i].nombre,agenda[i].telefono,agenda[i].email);
   }
}
	El archivo de eliminación de registros, por el momento únicamente contiene una salida por consola en la cual anuncia la acción que más adelante realizará. 
📂proyectodelcurso/  📂libAgenda/ 📄eliminarRegistro.c
	

	// libAgenda/eliminarRegistro.c
void eliminarRegistro(){
   printf("Vamos a eliminar un registro");
}
	Ocurre lo mismo que con el archivo de búsqueda de registros, que, por el momento, únicamente lanza un mensaje por pantalla. 
📂proyectodelcurso/  📂libAgenda/ 📄buscarRegistro.c
	// libAgenda/buscarRegistro.c
void buscarRegistro(){
   printf("Vamos a buscar un registro");
}
	En el menú principal hemos colocado todo el código que corresponde canto a la presentación inicial del menú, con las opciones que se muestran hacia el usuario, la captura de la entrada por parte del usuario, y la estructura de control switch, que nos permite realizar una serie de acciones en base a la entrada que haya introducido el usuario. 
📂proyectodelcurso/  📂libAgenda/ 📄menuPrincipal.c
	// libAgenda/menuPrincipal.c
void menuPrincipal(){
    // Mensaje de bienvenida
        printf("%s v%s \n",NOMBREPROGRAMA,VERSION);
        printf("%s \n",AUTOR);
        printf("\t 1 - Listado de registros \n");
        printf("\t 2 - Introducir un registro \n");
        printf("\t 3 - Eliminar un registro \n");
        printf("\t 4 - Buscar un registro \n");
        printf("\t 5 - Actualizar un registro \n");
        printf("Tu opcion: ");
        char opcion = getchar();
        printf("La opción que has seleccionado es: %c \n",opcion);
        switch(opcion){
            case '1':
                listadoRegistros();
                break;
       case '2':
                introducirRegistro();
                break;
       case '3':
                eliminarRegistro();
                break;
       case '4':
                buscarRegistro();
                break;
            case '5':
                actualizarRegistro();
                break;
       default:
           printf("La opción que has introducido no es válida");
           break;
        }
}
	Habiendo realizado esta separación en funciones, y habiendo almacenado cada una de las funciones en un archivo diferente, podremos comprobar como ahora nuestro proyecto es mucho más mantenible, ya que cada  archivo contiene únicamente el código fuente de aquella operación que va a realizar. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0066-agenda.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Programa agenda v1.0 
Jose Vicente Carratala 
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
Tu opcion: 1
La opción que has seleccionado es: 1 
Registro: Jose Vicente 12345678 info@josevicentecarratala.com 
Registro: Juan 53254 juan@josevicentecarratala.com 
Registro: Jaime 64566 jaime@josevicentecarratala.com 
MacBook-Pro-de-Jose:cursodec josevicente$ 
	



________________


📂proyectodelcurso/  📄main.c
	// agenda.c
/* Programa agenda
por Jose Vicente Carratala */
#define NOMBREPROGRAMA "Programa agenda"
#define VERSION "1.0"
#define AUTOR "Jose Vicente Carratala"
#include <stdio.h>
#include <string.h>
#include "libAgenda/datos.c"
#include "libAgenda/listadoRegistros.c"
#include "libAgenda/introducirRegistro.c"
#include "libAgenda/eliminarRegistro.c"
#include "libAgenda/buscarRegistro.c"
#include "libAgenda/actualizarRegistro.c"
#include "libAgenda/menuPrincipal.c"

int main(int argc, char *argv[]) {

   // Primer registro
   printf("\033[2J");
   strcpy(agenda[1].nombre,"Jose Vicente");
   strcpy(agenda[1].telefono,"12345678");
   strcpy(agenda[1].email,"info@josevicentecarratala.com");
   
   // Segundo registro
   strcpy(agenda[2].nombre,"Juan");
   strcpy(agenda[2].telefono,"53254");
   strcpy(agenda[2].email,"juan@josevicentecarratala.com");
   // Tercer registro
   strcpy(agenda[3].nombre,"Jaime");
   strcpy(agenda[3].telefono,"64566");
   strcpy(agenda[3].email,"jaime@josevicentecarratala.com");
        printf("\033[2J");
   menuPrincipal();
        
        return 0;
}
	Ahora, en los siguientes archivos es donde vamos a seguir trabajando con cada uno de los bloques del programa, para conseguir externalizar los correctamente.
 empezando con el archivo que contiene la estructura de cada uno de los registros, este archivo en principio que da igual que estaba, ya que define la plantilla de la estructura del registro de la agenda, y crea un  arreglo de estructuras de 100 unidades. 
📂proyectodelcurso/  📂libAgenda/ 📄datos.c
	// datos.c
struct RegistroAgenda{
       char nombre[50];
       char telefono[50];
       char email[50];
   };
   
   struct RegistroAgenda agenda[100];
   
   int longitudDatos = 3;
	En el listado de los registros, por una parte mantenemos el bucle for que se encarga de listar cada uno de los registros que tengamos en la agenda, y a continuación, se atrapa la entrada por parte del usuario, para que, en el caso de que pulse cualquier tecla, podamos volver al menú inicial.
 veamos como en este caso, por una parte atrapamos la entrada del usuario
getchar();
	 por otra parte enviamos un carácter de borrado de pantalla a la consola
 printf("\033[2J");
	 y a continuación invocamos al menú principal, para volver a tener el menú de nuevo en pantalla
menuPrincipal();
	 el código final de esta función queda de la siguiente forma 
📂proyectodelcurso/  📂libAgenda/ 📄listadoRegistros.c
	// listadoRegistros.c
void listadoRegistros(){
   printf("\033[2J");
   // Recorremos los registros uno a uno, los mostramos por pantalla
   for(int i = 1; i<=longitudDatos;i++){
       printf("Registro: %s %s %s \n",agenda[i].nombre,agenda[i].telefono,agenda[i].email);
   }
   // Volvemos al menu principal
   printf("Pulsa Enter para volver al menú principal \n");
   getchar();
   getchar();
   printf("\033[2J");
   menuPrincipal();
}
	En el código correspondiente a la introducción de un nuevo registro, en primer lugar borraremos completamente la pantalla
 printf("\033[2J");
	A partir de ese momento, para cada una de las piezas de información que queremos introducir dentro del programa, en primer lugar lanzamos un mensaje para que el usuario sepa que es lo que le vamos a preguntar
printf("Indica el nombre del contacto: \n");
	A continuación creamos una nueva variable que corresponde a un arreglo de caracteres, con un máximo de 100 unidades
char nombre[100];
	Y por último coma introducimos esa información dentro de una función de escaneado de entrada de usuario, ya que al estar trabajando con arreglos de caracteres no nos sirve la instrucción de getchar
scanf("%s",nombre);
	El código completo de esta función queda de la siguiente forma. Veremos como en el código completo del ejercicio hemos repetido la estructura que acabo de mencionar, para cada uno de los datos que queremos atrapar. 
📂proyectodelcurso/  📂libAgenda/ 📄introducirRegistro.c
	// introducirRegistro.c
void introducirRegistro(){
   printf("\033[2J");
   // Información al usuario
       printf("Vamos a introducir un registro \n");
   // Solicitamos el nombre
       printf("Indica el nombre del contacto: \n");
       char nombre[100];
       scanf("%s",nombre);
   // Solicitamos el telefono
       printf("Indica el telefono del contacto: \n");
       char telefono[100];
       scanf("%s",telefono);
   // Solicitamos el email
       printf("Indica el email del contacto: \n");
       char email[100];
       scanf("%s",email);
   // Aumentamos el indice de la matriz
       longitudDatos++;
   // Creamos una nueva estructura
       strcpy(agenda[longitudDatos].nombre,nombre);
       strcpy(agenda[longitudDatos].telefono,telefono);
       strcpy(agenda[longitudDatos].email,email);
   // Feedback al usuario
       printf("Registro añadido, pulsa una tecla para volver al menu inicial \n");
       getchar();
       getchar();
   // Volvemos al menu principal
       printf("\033[2J");
       menuPrincipal();
   
}
	Para la eliminación de registros vamos a utilizar un truco bastante sencillo para vaciar el registro que el usuario indique.
En primer lugar vamos a invocar a una operación de impresión para vaciar la pantalla
printf("\033[2J");
	A continuación, el usuario podrá introducir un carácter dentro de la consola coma en este caso, por ejemplo, un número
getchar();
	A continuación, el Registro será igualado a una variable llamada identificador que almacenará ese registro
int id = getchar();
	Y ahora, la parte importante, consiste en que tomaremos cada uno de los registros desde ese identificador en adelante, y copiaremos graba registro a continuación del registro actual, dentro del registro anterior.
for(int i = id;i<longitudDatos;i++){
           agenda[i] = agenda[i+1];
       }
	Esta metodología de trabajo, que en un principio podría parecer un poco extraña, nos va a permitir conseguir que el registro que hayamos seleccionado quede borrado coma y el reto de registros sobre escriban al registro actual.
longitudDatos--;
	Por supuesto coma tendremos que quitarle una unidad a la variable que mide la longitud de datos, para que el sistema pare una unidad antes cada vez que recorremos el arreglo
Por último, esperaremos a la entrada del usuario para borrar la pantalla y volver a comenzar la aplicación de nuevo. 
📂proyectodelcurso/  📂libAgenda/ 📄eliminarRegistro.c
	// eliminarRegistro.c
void eliminarRegistro(){
   printf("\033[2J");
   // Mensaje informativo para el usuario
       printf("Vamos a eliminar un registro");
   // Solicitamos el id a eliminar
       printf("Introduce el id del registro a eliminar: \n");
       getchar();
       int id = getchar();
   // Recorremos la matriz copiando el siguiente registro, en el anterior, a partir del registro indicado
       for(int i = id;i<longitudDatos;i++){
           agenda[i] = agenda[i+1];
       }
   // Recortamos la longitud de los datos
       longitudDatos--;
   // Volvemos al menu inicial
       printf("Pulsa Enter para volver al menu principal");
       getchar();
       getchar();
       printf("\033[2J");
       menuPrincipal();
}
	A continuación vamos a programar un buscador, mediante el cual seremos capaces de realizar una búsqueda en cada uno de los registros. para este ejemplo vamos a realizar un buscador utilizando el nombre del usuario, pero podríamos actuar de igual forma para buscar a través del teléfono oa través del correo electrónico.
En primer lugar invocamos a una operación de borrado de pantalla
printf("\033[2J");
	Y a continuación crearemos una nueva variable declarando que será un arreglo de 100 caracteres como máximo
char nombre[100];
	En el siguiente paso, introduciremos la entrada del usuario, mediante una operación de escaneo, dentro de esa variable
scanf("%i",nombre);
	Una vez que la hayamos introducido, es cuándo podremos recorrer uno a uno todos los datos que hayamos insertado dentro de la agenda
for(int i = 1;i<=longitudDatos;i++){
	Y utilizando la opción de comparación, es cuándo podremos comparar si el nombre que ha introducido el usuario en la línea de comando coincide exactamente con el nombre que existía en el arreglo de datos
if(strcmp(nombre,agenda[i].nombre) != 0){
	En ese caso, y solo en ese caso, es cuando se imprimirá el registro completo del usuario por pantalla
printf("Registro: %s %s %s \n",agenda[i].nombre,agenda[i].telefono,agenda[i].email);
	El código completo de la función será el siguiente 
📂proyectodelcurso/  📂libAgenda/ 📄buscarRegistro.c
	// buscarRegistro.c
void buscarRegistro(){
   printf("\033[2J");
   // Mensaje informativo para el usuario
       printf("Vamos a buscar un registro \n");
   // Introducimos el nombre a buscar
       printf("Introduce el nombre del contacto: \n");
       char nombre[100];
       scanf("%i",nombre);
   // Recorremos la matriz registro a registro, comparando la cadena
       for(int i = 1;i<=longitudDatos;i++){
           if(strcmp(nombre,agenda[i].nombre) != 0){
               printf("Registro: %s %s %s \n",agenda[i].nombre,agenda[i].telefono,agenda[i].email);
           }
       }
   // Volvemos al menu principal
       printf("Pulsa Enter para volver al menu principal");
       getchar();
       getchar();
       printf("\033[2J");
       menuPrincipal();
}
	La operación de actualización de registros probablemente sea la más compleja que vamos a programar dentro de esta aplicación.
En primer lugar coma después del  preceptivo borrado de pantalla
printf("\033[2J");
	Le pediremos al usuario que introduzca un nuevo identificador, y lo atraparemos dentro de una variable
int idmodificar = getchar();
	Mediante este sencillo truco podemos atrapar un carácter de un número, y restándole 48 posiciones, podemos localizar su correspondiente identificador en código ASCII
idmodificar -= 48;
	Ahora, una vez que tenemos localizado el identificador, en primer lugar le mostraremos al usuario el nombre que había anteriormente dentro de ese contacto
printf("Introduce el nuevo nombre del contacto: (anterior: %s) \n",agenda[idmodificar].nombre);
	Creamos un nuevo arreglo de caracteres con un máximo de 100 unidades
char nombre[100];
	Y realizamos una operación de escaneo de entrada de usuario para guardarnos temporalmente la información dentro de esa variable
scanf("%s",nombre);
	Por último, una vez que hayamos realizado esta operación para solicitar tanto el nombre, como el teléfono, como el correo electrónico, realizaremos una sobre escritura de ese registro mediante el siguiente código
strcpy(agenda[idmodificar].nombre,nombre);
	El código completo de esta función queda de la siguiente forma 
📂proyectodelcurso/  📂libAgenda/ 📄actualizarRegistro.c
	// actualizarRegistro.c
void actualizarRegistro(){
   printf("\033[2J");
   // Informamos al usuario
       printf("Vamos a actualizar un registro \n");
   // Introducimos el identificador del contacto
       printf("Introduce el id del contacto: \n");
       getchar();
       int idmodificar = getchar();
       idmodificar -= 48; // Convertimos de ASCII a numero
   // Informamos al usuario del id que se va a modificar
       printf("Has introducido el id para modificar: %d \n",idmodificar);
   // Solicitamos el nuevo nombre
       printf("Introduce el nuevo nombre del contacto: (anterior: %s) \n",agenda[idmodificar].nombre);
       char nombre[100];
       scanf("%s",nombre);
   // Solicitamos el nuevo telefono
       printf("Introduce el nuevo telefono del contacto: (anterior: %s) \n",agenda[idmodificar].telefono);
       char telefono[100];
       scanf("%s",telefono);
   // Solicitamos el nuevo email
       printf("Introduce el nuevo email del contacto: (anterior: %s) \n",agenda[idmodificar].email);
       char email[100];
       scanf("%s",email);
   // Creamos una nueva estructura
       strcpy(agenda[idmodificar].nombre,nombre);
       strcpy(agenda[idmodificar].telefono,telefono);
       strcpy(agenda[idmodificar].email,email);
   // Feedback al usuario
       printf("Registro añadido, pulsa una tecla para volver al menu inicial \n");
       getchar();
       getchar();
   // Volvemos al menu principal
       printf("\033[2J");
       menuPrincipal();
   
}
	Por último coma la función del menú principal se queda prácticamente como la teníamos hasta el momento, ya que era una función cuya única misión era lanzar estéticamente el menú por pantalla, atrapar la entrada del usuario, y ejecutar una función UDF traen base a cual haya sido la entrada que el usuario haya especificado 
📂proyectodelcurso/  📂libAgenda/ 📄menuPrincipal.c
	// menuPrincipal.c
void menuPrincipal(){
        printf("\033[2J");
    // Mensaje de bienvenida
        printf("%s v%s \n",NOMBREPROGRAMA,VERSION);
        printf("%s \n",AUTOR);
        printf("\t 1 - Listado de registros \n");
        printf("\t 2 - Introducir un registro \n");
        printf("\t 3 - Eliminar un registro \n");
        printf("\t 4 - Buscar un registro \n");
        printf("\t 5 - Actualizar un registro \n");
        printf("Tu opcion: ");
        char opcion = getchar();
        printf("La opción que has seleccionado es: %c \n",opcion);
        switch(opcion){
            case '1':
                listadoRegistros();
                break;
       case '2':
                introducirRegistro();
                break;
       case '3':
                eliminarRegistro();
                break;
       case '4':
                buscarRegistro();
                break;
            case '5':
                actualizarRegistro();
                break;
       default:
           printf("La opción que has introducido no es válida");
            printf("Pulsa Enter para volver al menú principal \n");
                    getchar();
                    getchar();
                    printf("\033[2J");
                    menuPrincipal();
           
           break;
        }
}
	







________________




15. Persistencia en archivos
________________


15.1. Persistencia, ¿qué es?
Hasta ahora, detrás del programa que hemos generado, trata información que existe previamente en variables, o bien que podemos introducir de forma manual.
El programa realiza las operaciones que sean necesarias, y finalmente, devuelve un resultado al ser humano.
Sin embargo, en el trabajo diario de un ser humano, generalmente, es necesario que esta información quede guardada de una forma permanente en algún soporte estable.
Esto quiere decir que, hasta el momento, cada programa que hemos hecho olvidar completamente sus datos en el momento que el programa es cerrado.
Si ponemos como ejemplo el programa que estamos desarrollando a lo largo de este curso, es decir, la agenda, nos habremos dado cuenta, que, al final de la ejecución del programa, todos los datos que hemos introducido quedan completamente perdidos, y cuando ejecutamos el programa de nuevo, tenemos que volverlos a introducir.
Huelga decir lo inconveniente que es este hecho, ya que, lo que muy probablemente desearíamos, es que todo el trabajo que hemos creado quede guardado de alguna manera, tal que la próxima vez que volvamos a ejecutar nuestro programa, los datos se encuentren en el mismo punto en el que los dejamos.
Esto exactamente es la persistencia.
Consiste, básicamente, en asegurar que los datos quedan guardados en un soporte persistente, es decir, no en un soporte volátil como es por ejemplo la memoria RAM, sino en un soporte en los que los datos puedan sobrevivir, tal y como por ejemplo un disco duro, o una tarjeta de memoria.
15.2. Persistencia en archivos de texto
Una de las formas más básica y más clásica de realizar esta persistencia es utilizando archivos dentro del ordenador.
En un momento dado, el programa puede escribir en estos archivos la información que necesite, y recuperar, mediante una operación de lectura, la información que quede contenida dentro de este archivo.
Existen fundamentalmente dos tipos de archivo en cualquier sistema operativo, los archivos binarios, y los archivos de texto.
El soporte para escribir archivos binarios y para poder leerlos depende inmensamente del lenguaje de programación en el que estemos trabajando.
Sin embargo, prácticamente cualquier lenguaje de programación incluye soporte para poder escribir y leer archivos en formato texto.
Además, las instrucciones necesarias para poder leer y escribir archivos de texto, si bien rara vez se encuentran en el núcleo de un lenguaje de programación, sí que suelen encontrarse en esa colección de librerías por defecto añadidas al núcleo de cualquier lenguaje de programación.
15.3. escritura de archivos.
A continuación se muestra un ejemplo de código en el que, en primer lugar, se hace uso de una librería, con la que importamos la capacidad de poder leer y poder escribir archivos de texto.
A continuación, dentro del bloque inicial, dentro de la función principal, establecemos el código que nos permite, en primer lugar, abrir un archivo, y a continuación, escribir texto dentro de él
#include <stdio.h>

int main(int argc, char** argv) {
   FILE *archivo;
   archivo = fopen("prueba.txt","w");
   fprintf(archivo,"Esto es una prueba \n");
   fclose(archivo);
   return 0;
}
	

Al ejecutar este programa podremos comprobar como coma el sistema abre un archivo, además en modo de escritura, guarda una cadena de texto dentro del coma y cierra el archivo. 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0063-escribir.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out
	Dentro de la consola o de la terminal no podremos tener demasiado retorno hacia el usuario, por lo que deberemos abrir el archivo llamado prueba.txt, que sin duda habrá aparecido en el mismo directorio en el que estamos trabajando, para poder comprobar cómo dicho archivo contendrá la cadena de texto que acabamos de insertar 
15.4. El cierre de los recursos.
Siempre que trabajamos con archivos externos al propio programa principal, se entiende que, en el momento en el que abrimos un archivo, realmente estamos abriendo un recurso.
Esto es importante ya que, en la mayoría de ocasiones, cuando se abre un recurso este recurso queda bloqueado, para impedir que, mientras que tenemos el recurso abierto, cualquier otra persona desde cualquier otra ubicación pueda escribir dentro de él, introduciendo una situación de inconsistencia.
De esta manera, si el programa es capaz de bloquear un recurso para darnos acceso exclusivo a él, debemos tener cuidado de liberar el recurso una vez que hemos finalizado su utilización.
Es por esto que al final del programa que hemos mencionado anteriormente existe esta línea:
Que nos permite que el programa cierre, de manera manual, el recurso que estaba siendo utilizado.
aunque la mayoría de lenguajes de programación tienen mecanismos de cierre automático de recursos, bien cuando se dejan de usar, o bien cuando el programa se cierra, es importante acostumbrarse a cerrar los recursos de forma manual, ya que de otro modo, podemos cerrar el acceso accidentalmente a un recurso de manera temporal o de manera permanente, dificultando el trabajo de otras personas, o incluso de nosotros mismos cuando queremos acceder a ese recurso a través de cualquier otro medio que no sea el programa que lo ha bloqueado.
15.5. Cómo leer un archivo
Una vez que ya somos capaces de escribir en un archivo, a continuación queremos leer su contenido.
Generalmente, en cualquier lenguajes de programación, leer un archivo de texto se basa en los siguientes pasos:
En primer lugar, abrimos el recurso y, opcionalmente, indicamos que la apertura es el modo de lectura.
A continuación, generalmente, las librerías de lectura de archivos trabajan línea a línea.
Esto quiere decir que tenemos que apoyarnos en una estructura de tipo guay que vaya recorriendo el archivo línea a línea, permitiéndonos realizar una operación sobre cada una de las líneas leídas.
En el ejemplo que ponemos a continuación, la operación consiste simplemente en devolver en la pantalla el contenido del archivo, aunque por supuesto, la operación podría consistir en introducir la línea en la memoria, trabajar con ella, etc.
#include <stdio.h>

int main(int argc, char** argv) {
   char cadena[100];
   FILE *archivo;
   archivo = fopen("prueba.txt","r");
   fprintf(archivo,"Esto es una prueba \n");
   while( fgets (cadena, 60, archivo)!=NULL ){
       puts(cadena);
   }
   fclose(archivo);
   return 0;
}
	Si ejecutamos este ejercicio cómo podremos comprobar como la consola nos permite introducir un texto, y una vez que hayamos introducido ese texto, el programa escribir a todo aquello que hayamos introducido dentro de un archivo llamado prueba.txt
 a continuación podremos abrir ese archivo llamado prueba.txt, y comprobar que aquello que hayamos introducido en la consola aparecerá correctamente dentro del archivo 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0064-leer.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
Esto es una prueba 

MacBook-Pro-de-Jose:cursodec josevicente$ 
	

15.6. Ejercicio del curso
A continuación, vamos a aplicar todo aquello que acabamos de aprender para ser capaces de realizar una aplicación informática que tenga una mínima capacidad de persistencia de datos, en el sentido de que, en un momento dado, después de una sesión de trabajo, podamos guardar todo a todos aquellos datos que hayamos introducido dentro de un archivo de texto con una estructura mínima.
A continuación vamos a repasar, uno a uno, los archivos que contiene nuestro proyecto, para analizar en cuáles de estos archivos se han producido modificaciones.
Empezamos con el archivo principal, el cual no habrá sufrido ningún tipo de modificación, ya que en este archivo no se realizaba ninguna escritura al disco duro 
Únicamente deberemos tener en cuenta incluir los nuevos archivos que son con los que vamos a trabajar en esta parte del ejercicio, que se encargarán de guardar y de recuperar datos. 
📂proyectodelcurso/  📂proyectodelcurso/   📄main.c
	// agenda.c
/* Programa agenda
por Jose Vicente Carratala */
#define NOMBREPROGRAMA "Programa agenda"
#define VERSION "1.0"
#define AUTOR "Jose Vicente Carratala"
#include <stdio.h>
#include <string.h>
#include "libAgenda/datos.c"
#include "libAgenda/listadoRegistros.c"
#include "libAgenda/introducirRegistro.c"
#include "libAgenda/eliminarRegistro.c"
#include "libAgenda/buscarRegistro.c"
#include "libAgenda/actualizarRegistro.c"
#include "libAgenda/guardarDatos.c"
#include "libAgenda/recuperarDatos.c"
#include "libAgenda/menuPrincipal.c"

int main(int argc, char *argv[]) {

   // Primer registro
   printf("\033[2J");
   strcpy(agenda[1].nombre,"Jose Vicente");
   strcpy(agenda[1].telefono,"12345678");
   strcpy(agenda[1].email,"info@josevicentecarratala.com");
   
   // Segundo registro
   strcpy(agenda[2].nombre,"Juan");
   strcpy(agenda[2].telefono,"53254");
   strcpy(agenda[2].email,"juan@josevicentecarratala.com");
   // Tercer registro
   strcpy(agenda[3].nombre,"Jaime");
   strcpy(agenda[3].telefono,"64566");
   strcpy(agenda[3].email,"jaime@josevicentecarratala.com");
        printf("\033[2J");
   menuPrincipal();
        
        return 0;
}
	En el menú principal tampoco existe ninguna modificación con respecto a la versión anterior del ejercicio, ya que el menú principal muestra las opciones disponibles para el usuario, atrapa la opción que el usuario haya seleccionado, y realiza una llamada a una de las funciones externas que hemos creado 
Únicamente crearemos dos nuevas entradas, con el identificador número 6 y con el identificador número 7, para llamar a dos nuevas funciones que se encargarán coma la número 6 de guardar los datos en un archivo, y la número 7 de recuperar los datos desde un archivo 
📂proyectodelcurso/  📂libAgenda/ 📄menuPrincipal.c
	// menuPrincipal.c
void menuPrincipal(){
        printf("\033[2J");
    // Mensaje de bienvenida
        printf("%s v%s \n",NOMBREPROGRAMA,VERSION);
        printf("%s \n",AUTOR);
        printf("\t 1 - Listado de registros \n");
        printf("\t 2 - Introducir un registro \n");
        printf("\t 3 - Eliminar un registro \n");
        printf("\t 4 - Buscar un registro \n");
        printf("\t 5 - Actualizar un registro \n");
        printf("\t 6 - Guardar datos en un archivo \n");
        printf("\t 7 - Recuperar datos desde un archivo \n");
        printf("Tu opcion: ");
        char opcion = getchar();
        printf("La opción que has seleccionado es: %c \n",opcion);
        switch(opcion){
            case '1':
                listadoRegistros();
                break;
       case '2':
                introducirRegistro();
                break;
       case '3':
                eliminarRegistro();
                break;
       case '4':
                buscarRegistro();
                break;
            case '5':
                actualizarRegistro();
                break;
      case '6':
                guardarDatos();
                break;
      case '7':
                recuperarDatos();
                break;
       default:
           printf("La opción que has introducido no es válida");
            printf("Pulsa Enter para volver al menú principal \n");
                    getchar();
                    getchar();
                    printf("\033[2J");
                    menuPrincipal();
           
           break;
        }
}
	El archivo de guardado de datos aplicar a todo aquello que hemos aprendido dentro del bloque anterior.
En primer lugar creamos un identificador que será de tipo file, ya que hemos cargado la librería correspondiente para poder utilizar este tipo concreto de datos
FILE *archivo;
	Una vez que dentro de ese identificador smooshins anciado todo aquello que tiene la librería de archivo, es cuándo podemos abrir un documento de texto coma y le indicaremos que vamos a realizar una serie de operaciones de escritura
 archivo = fopen("agenda.txt","w");
	Ahora que lo tenemos abierto, vamos a recorrer uno a uno todos los registros que previamente hemos ido definiendo dentro del programa
for(int i = 1; i<=longitudDatos;i++){
	Y para cada uno de estos registros, los guardaremos dentro del archivo de texto, con un formato tal que los separaremos mediante una barra vertical
fprintf(archivo,"%s|%s|%s \n",agenda[i].nombre,agenda[i].telefono,agenda[i].email);
	Por último, cerraremos el recurso que hemos abierto
 fclose(archivo);
	Es importante darnos cuenta de que la barra vertical es un carácter de separación libre, que yo he escogido por la sencilla razón de que es un carácter que el usuario no suele introducir ni en los nombres de persona, ni en los teléfonos, ni tampoco en los correos electrónicos. Lo único importante en este caso es que, si para escribir un archivo he utilizado una barra vertical, para leer un archivo tendré que utilizar la misma barra vertical.
 por último, el código completo de la aplicación queda de la siguiente forma 
📂proyectodelcurso/  📂libAgenda/ 📄guardarDatos.c
	// guardarDatos.c
void guardarDatos(){
   printf("\033[2J");
   // Creamos un archivo
   FILE *archivo;
   archivo = fopen("agenda.txt","w");
   // Recorremos los registros uno a uno, los mostramos por pantalla
   for(int i = 1; i<=longitudDatos;i++){
       fprintf(archivo,"%s|%s|%s \n",agenda[i].nombre,agenda[i].telefono,agenda[i].email);
   }
   fclose(archivo);
   // Volvemos al menu principal
   printf("Pulsa Enter para volver al menú principal \n");
   getchar();
   getchar();
   printf("\033[2J");
   menuPrincipal();
}
	La función de recuperación de registros funcionará de una forma similar al caso anterior, pero evidentemente realizando la operación inversa.
En primer lugar coma vamos a definir un caracter delimitador que coma igual que he comentado en la parte anterior de este ejercicio, será la barra vertical.
const char delimitador[2] = "|";
	Durante la realización de este ejercicio, el lector puede usar su propio carácter separador, con la única condición de que el carácter separador sea el mismo cuando se escribe el archivo, que cuando se lee.
A continuación abrimos un identificador qué es de tipo file
FILE *archivo;
	Y una vez que hemos cargado esa identificador, abrimos el archivo agenda txt, pero, en este caso, únicamente en modo lectura.
archivo = fopen("agenda.txt","r");
	A continuación, dentro de un bucle while, leemos una a una cada una de las líneas contenidas dentro del archivo
while( fgets (cadena, 60, archivo)!=NULL ){
	Para cada una de las líneas, partimos la línea en diferentes elementos utilizando el carácter delimitador, que para este caso ha sido la barra vertical
partido = strtok(cadena, delimitador);
	Y por lo tanto, a continuación, dentro de otra estructura while anidado dentro de la estructura while anterior
while( partido != NULL ) {
	Introducimos cada uno de los datos contenidos en el archivo en las propiedades correspondientes a su estructura.
if(contador == 0){strcpy(agenda[longitudDatos].nombre,partido);}
	Tengamos en cuenta que estamos utilizando  la variable de longitud de datos para especificar que, para cada uno de los datos que hayan sido leídos desde el archivo, la longitud debe sumar un valor, de la misma forma que si estuviéramos introduciendo datos manualmente desde la terminal
longitudDatos++;
	Por lo tanto, el código completo del ejercicio queda de la siguiente forma 
📂proyectodelcurso/  📂libAgenda/ 📄guardarDatos.c
	// recuperarDatos.c
void recuperarDatos(){
       printf("\033[2J");
   // Declaraciones iniciales
       char cadena[80];
      const char delimitador[2] = "|";
      char *partido;
      FILE *archivo;
  // Abrimos un archivo
   archivo = fopen("agenda.txt","r");
  // Leemos el archivo linea a linea
       while( fgets (cadena, 60, archivo)!=NULL ){
           // Partimos lineas a structs
               partido = strtok(cadena, delimitador);
               int contador = 0;
               longitudDatos++;
               while( partido != NULL ) {
                 if(contador == 0){strcpy(agenda[longitudDatos].nombre,partido);}
                 if(contador == 1){strcpy(agenda[longitudDatos].telefono,partido);}
                 if(contador == 2){strcpy(agenda[longitudDatos].email,partido);}
                 partido = strtok(NULL, delimitador);
                 contador++;
              }
       }
  // Feedback al usuario
       printf("Registros cargados, pulsa una tecla para volver al menu inicial \n");
       getchar();
       getchar();
   // Volvemos al menu principal
       printf("\033[2J");
       menuPrincipal();
  
}
	

15.7. Sobre la instrucción de partir cadenas a matriz
Para el ejercicio anterior hemos utilizado una de las funciones incluidas dentro de la librería de cadenas del lenguaje de programación C, que nos permite tomar una cadena de una longitud considerable, y partirla en varias cadenas, que formarán parte de un nuevo arreglo, utilizando un carácter como criterio de carácter separador.
En este siguiente ejemplo que se muestra a continuación, en primer lugar creamos un arreglo de caracteres, que contendrá la siguiente cadena
char cadena[80] = "primero|segundo|tercero";
	A continuación, dentro de otra variable, introducimos el carácter que tomaremos como delimitador, que en este caso, parece claro que será una barra vertical, pero podría ser cualquier otro carácter definido por el usuario
const char delimitador[2] = "|";
	Por último definimos un puntero a un identificador llamado partido coma que contendrá cada uno de los elementos resultantes de la división de la cadena original
char *partido;
	Por lo tanto a continuación, realizamos una igualación en la que decimos que el identificador partido es igual a la separación de la cadena utilizando el delimitador
partido = strtok(cadena, delimitador);
	Por último, como demostración, utilizaremos una estructura while para recorrer uno a uno los elementos del identificador partido, y comprobar como de esa forma que cada uno de los elementos de la cadena ha quedado guardado de forma individual
while( partido != NULL ) {
     printf( " %s\n", partido );
   
     partido = strtok(NULL, delimitador);
  }
	El código completo del ejercicio quedará de la siguiente forma 
// main.c
#include <stdio.h>
#include <string.h>

int main(int argc, char** argv) {
   char cadena[80] = "primero|segundo|tercero";
  const char delimitador[2] = "|";
  char *partido;
  
  partido = strtok(cadena, delimitador);
  
  while( partido != NULL ) {
     printf( " %s\n", partido );
   
     partido = strtok(NULL, delimitador);
  }
  
  return(0);
}
	Al ejecutar este ejercicio en la terminal o en la consola, podremos comprobar cómo a partir de una cadena original, hemos conseguido cortar esa cadena en diferentes trozos, pudiendo elegir por nuestra parte cuál es el carácter delimitador
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0078-partir.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
primero
segundo
tercero
	

________________
16. Librería de tiempo
________________


16.1. Control del tiempo
Dentro de la mayoría de los programas, la gestión del tiempo juega un papel fundamental.
Por ejemplo, cuando usamos registros, cuando un programa trabaja con registros que en un momento dado escribimos y que más adelante queremos leer, muchas veces es necesario introducir elementos tales como por ejemplo la fecha en la que ese registro quedó escrito.
De esta forma, en la gran mayoría de lenguajes de programación, junto al núcleo, es costumbre disponer de una librería específica de tratamiento del tiempo, que a su vez se suele dividir en dos librerías, una de tratamiento de la fecha, y otra de tratamiento del tiempo.
Esto puede diferir a lo largo de los lenguajes de programación, pero generalmente, hay una serie de operaciones para tratar con años, meses, ideas, y hay otras operaciones para trabajar con horas, minutos, y segundos.
Adicionalmente, en cada una de las librerías, puede haber instrucciones adicionales tales como por ejemplo las que permiten contabilizar los números de días de cada mes, el número de semanas del año, los años bisiestos, etc.
En el caso del lenguaje de programación C, lo primero que tenemos que hacer para trabajar con fechas, es importar la siguiente librería.
#include <stdio.h>
#include <time.h>

int main(int argc, char *argv[]) {
   
}
	A continuación, y sólo a partir de ese momento, es cuando podemos crear variables cuyo tipo de datos corresponde con la librería que acabamos de importar:
#include <stdio.h>
#include <time.h>

int main(int argc, char *argv[]) {
   time_t tiempo;
}
	A continuación se describe un sencillo programa que se encarga de devolver en pantalla la fecha actual.
#include <stdio.h>
#include <time.h>

int main(int argc, char *argv[]) {
   time_t tiempo;
   char* tiempoCadena;
   tiempo = time(NULL);
   tiempoCadena = ctime(&tiempo);
   
   printf("El tiempo actual es: %s \n",tiempoCadena);
}
	

________________
16.2. Clicks de ejecución de procesador
A través del ejemplo anterior hemos sido capaces de obtener la lectura del tiempo del sistema, en un formato pre establecido y estandarizado.
En este ejemplo, usando la misma librería de tiempo, utilizamos una variable llamada clock, que nos permite obtener el número de clicks que han sido ejecutados por el reloj del procesador, desde que el programa está en funcionamiento
Los clics no se miden en tiempo, sino en operaciones, en instrucciones ejecutadas por el procesador
Este tipo de medida puede ser de utilidad para realizar comparaciones de rendimiento entre diferentes arquitecturas, en un mismo programa 
#include <stdio.h>
#include <time.h>

int main() {
    clock_t t1;  
   t1 = clock();
   printf("El reloj es: %li \n ",t1);
}
	Al ejecutar este código en la terminal o en la consola, podremos comprobar como aparecen el número de clics generado por el reloj del sistema.
 deberemos tener en cuenta que coma en cuanto al formateo de la cadena de caracteres, el formato correcto para obtener este dato será %li 
MacBook-Pro-de-Jose:cursodec josevicente$ gcc 0085-reloj.c 
MacBook-Pro-de-Jose:cursodec josevicente$ ./a.out 
El reloj es: 4950 
	

16.3. Tiempo
Volviendo al primer ejemplo ilustrado en este capítulo, es posible que, en un momento dado, nos interese o tener una marca de tiempo en un formato más personalizado
De esta forma, el siguiente ejemplo sigue usando la librería de tiempo, pero desglosa la información en 6 unidades principales, que son el año, el mes, el día, la hora, el minuto, y el segundo
Como podremos comprobar, mediante el almacenaje de estos datos en variables, más adelante, podemos formatear una fecha de una forma completamente personalizada 
#include <stdio.h>
#include <time.h>

int main() {
   time_t t = time(NULL);
   struct tm tm = *localtime(&t);
   printf(
       "tiempo: %d-%d-%d %d:%d:%d\n", 
       tm.tm_year + 1900, 
       tm.tm_mon + 1, 
       tm.tm_mday, 
       tm.tm_hour, 
       tm.tm_min, 
       tm.tm_sec
       );
}
	16.4. Proyecto del curso
A continuación, aplicamos lo que hemos aprendido en esta unidad al ejercicio que estamos desarrollando a lo largo de la publicación
La aplicación de la librería de tiempo, en este caso, sucede de forma que, en el menú principal, cada vez que lo ejecutamos, obtenemos un desglose del momento exacto en el que estamos ejecutando nuestro programa. nueva línea
Disfrutamos, una vez más, de la aplicación de la filosofía de divide y vencerás, al haber externalizado cada una de las funciones en un archivo de código de fuente diferente
De esta forma, ahora no tenemos que ir arriba y abajo en un largo programa principal, buscando exactamente la línea en la que se encuentra el código que creemos modificar.
Como podemos comprobar en el listado de archivos a continuación, únicamente tenemos que modificar aquellos archivos donde intervenga la entrada del tiempo, como es el archivo principal, una nueva función creada a propósito para este efecto, y el archivo del menú principal. el resto de archivos de funciones, quedan completamente intacto 
📂proyectodelcurso/  📂libAgenda/ 📄dameFecha.c
	// dameFecha.c
#include <stdio.h>
#include <time.h>

void dameFecha() {
   time_t t = time(NULL);
   struct tm tm = *localtime(&t);
   printf(
       "hoy es: %d-%d-%d %d:%d:%d\n", 
       tm.tm_year + 1900, 
       tm.tm_mon + 1, 
       tm.tm_mday, 
       tm.tm_hour, 
       tm.tm_min, 
       tm.tm_sec
       );
}
	En el archivo principal del proyecto, incluiremos el archivo que acabamos de realizar, es decir, el archivo que nos proporciona la fecha, a través de una función, y lo dejaremos preparado para poder utilizarlo en cualquier momento dentro de la ejecución del programa que estamos desarrollando a lo largo del curso. 
📂proyectodelcurso/  📄main.c
	// agenda.c
/* Programa agenda
por Jose Vicente Carratala */
#define NOMBREPROGRAMA "Programa agenda"
#define VERSION "1.0"
#define AUTOR "Jose Vicente Carratala"
#include <stdio.h>
#include <string.h>
#include "libAgenda/datos.c"
#include "libAgenda/dameFecha.c"
#include "libAgenda/listadoRegistros.c"
#include "libAgenda/introducirRegistro.c"
#include "libAgenda/eliminarRegistro.c"
#include "libAgenda/buscarRegistro.c"
#include "libAgenda/actualizarRegistro.c"
#include "libAgenda/guardarDatos.c"
#include "libAgenda/recuperarDatos.c"
#include "libAgenda/menuPrincipal.c"

int main(int argc, char *argv[]) {

   // Primer registro
   printf("\033[2J");
   strcpy(agenda[1].nombre,"Jose Vicente");
   strcpy(agenda[1].telefono,"12345678");
   strcpy(agenda[1].email,"info@josevicentecarratala.com");
   
   // Segundo registro
   strcpy(agenda[2].nombre,"Juan");
   strcpy(agenda[2].telefono,"53254");
   strcpy(agenda[2].email,"juan@josevicentecarratala.com");
   // Tercer registro
   strcpy(agenda[3].nombre,"Jaime");
   strcpy(agenda[3].telefono,"64566");
   strcpy(agenda[3].email,"jaime@josevicentecarratala.com");
        printf("\033[2J");
   menuPrincipal();
        
        return 0;
}
	Dentro del archivo que contiene el menú principal, realizaremos una llamada a la función dame fecha, para que, cada vez que ejecutemos el menú principal del programa, aparezca la fecha en la que estamos realizando dicha ejecución. 
📂proyectodelcurso/  📂libAgenda/ 📄menuPrincipal.c
	// menuPrincipal.c
void menuPrincipal(){
        printf("\033[2J");
    // Mensaje de bienvenida
        printf("%s v%s \n",NOMBREPROGRAMA,VERSION);
        printf("%s \n",AUTOR);
        dameFecha();
        printf("\t 1 - Listado de registros \n");
        printf("\t 2 - Introducir un registro \n");
        printf("\t 3 - Eliminar un registro \n");
        printf("\t 4 - Buscar un registro \n");
        printf("\t 5 - Actualizar un registro \n");
        printf("\t 6 - Guardar datos en un archivo \n");
        printf("\t 7 - Recuperar datos desde un archivo \n");
        printf("Tu opcion: ");
        char opcion = getchar();
        printf("La opción que has seleccionado es: %c \n",opcion);
        switch(opcion){
            case '1':
                listadoRegistros();
                break;
       case '2':
                introducirRegistro();
                break;
       case '3':
                eliminarRegistro();
                break;
       case '4':
                buscarRegistro();
                break;
            case '5':
                actualizarRegistro();
                break;
      case '6':
                guardarDatos();
                break;
      case '7':
                recuperarDatos();
                break;
       default:
           printf("La opción que has introducido no es válida");
            printf("Pulsa Enter para volver al menú principal \n");
                    getchar();
                    getchar();
                    printf("\033[2J");
                    menuPrincipal();
           
           break;
        }
}
	

________________


Dentro del archivo de dato,s creamos una definición de la función del menú principal, para que, al ejecutarse, no proporcione un error cíclico.
// datos.c

void menuPrincipal();
struct RegistroAgenda{
       char nombre[50];
       char telefono[50];
       char email[50];
   };
   
   struct RegistroAgenda agenda[100];
   
   int longitudDatos = 3;
	Adicionalmente, dentro del archivo de búsqueda de registros, nos aseguraremos que el nombre se registra como una cadena de caracteres, y no como un número entero.
// buscarRegistro.c
void buscarRegistro(){
   printf("\033[2J");
   // Mensaje informativo para el usuario
       printf("Vamos a buscar un registro \n");
   // Introducimos el nombre a buscar
       printf("Introduce el nombre del contacto: \n");
       char nombre[100];
       scanf("%c",nombre);
   // Recorremos la matriz registro a registro, comparando la cadena
       for(int i = 1;i<=longitudDatos;i++){
           if(strcmp(nombre,agenda[i].nombre) != 0){
               printf("Registro: %s %s %s \n",agenda[i].nombre,agenda[i].telefono,agenda[i].email);
           }
       }
   // Volvemos al menu principal
       printf("Pulsa Enter para volver al menu principal");
       getchar();
       getchar();
       printf("\033[2J");
       menuPrincipal();
}
	









________________
17. Estado final del ejercicio
________________


17.1. Estructura del proyecto
Una vez finalizado el proyecto, vamos a realizar un repaso y un resumen de todos los archivos que intervienen en el mismo, junto con su código, en su estado final, para que puedas comprobar que tu proyecto coincide con el ejercicio que se desarrolla durante la publicación.
  

En la carpeta principal, encontramos el archivo que contiene el código inicial del proyecto, main.c, y el archivo compilado, agenda (agenda.exe en sistemas operativos Windows)
Dentro de la carpeta libAgenda, encontraremos cada uno de los archivos de código en los que hemos ido externalizando las funciones que necesita nuestro programa,
17.2. Contenido del proyecto
A continuación, se detalla el contenido de cada uno de los archivos que componen el proyecto.
17.2.1. Archivo principal
El archivo principal contiene:
* Comentarios de inicio de la aplicación
* Definición de constantes
* Inclusión de librerías estándar
* Inclusión de los archivos accesorios del proyecto
* Función principal
   * Limpiado de pantalla
   * Creación de registros de inicio
   * Llamada al menú principal
📂proyectodelcurso/   📄main.c
	// agenda.c
/* Programa agenda
por Jose Vicente Carratala */
#define NOMBREPROGRAMA "Programa agenda"
#define VERSION "1.0"
#define AUTOR "Jose Vicente Carratala"
#include <stdio.h>
#include <string.h>
#include "libAgenda/datos.c"
#include "libAgenda/dameFecha.c"
#include "libAgenda/listadoRegistros.c"
#include "libAgenda/introducirRegistro.c"
#include "libAgenda/eliminarRegistro.c"
#include "libAgenda/buscarRegistro.c"
#include "libAgenda/actualizarRegistro.c"
#include "libAgenda/guardarDatos.c"
#include "libAgenda/recuperarDatos.c"
#include "libAgenda/menuPrincipal.c"

int main(int argc, char *argv[]) {

   // Primer registro
   printf("\033[2J");
   strcpy(agenda[1].nombre,"Jose Vicente");
   strcpy(agenda[1].telefono,"12345678");
   strcpy(agenda[1].email,"info@josevicentecarratala.com");
   
   // Segundo registro
   strcpy(agenda[2].nombre,"Juan");
   strcpy(agenda[2].telefono,"53254");
   strcpy(agenda[2].email,"juan@josevicentecarratala.com");
   // Tercer registro
   strcpy(agenda[3].nombre,"Jaime");
   strcpy(agenda[3].telefono,"64566");
   strcpy(agenda[3].email,"jaime@josevicentecarratala.com");
        printf("\033[2J");
   menuPrincipal();
        
        return 0;
}
	



17.2.2. Actualizar Registro
El archivo de actualizar registro, realiza las siguientes acciones:
* Anuncia la operación a realizar
* Solicita al usuario el ID del registro a actualizar (índice del array)
* Le solicita los nuevos datos (al tiempo que le muestra los datos anteriores que van a ser sobre escritos)
* Sobre escribe los datos antiguos con los nuevos
* Vuelve al menú principal
📂proyectodelcurso/  📂libAgenda/ 📄actualizarRegistro.c
	// actualizarRegistro.c
void actualizarRegistro(){
   printf("\033[2J");
   // Informamos al usuario
       printf("Vamos a actualizar un registro \n");
   // Introducimos el identificador del contacto
       printf("Introduce el id del contacto: \n");
       getchar();
       int idmodificar = getchar();
       idmodificar -= 48; // Convertimos de ASCII a numero
   // Informamos al usuario del id que se va a modificar
       printf("Has introducido el id para modificar: %d \n",idmodificar);
   // Solicitamos el nuevo nombre
       printf("Introduce el nuevo nombre del contacto: (anterior: %s) \n",agenda[idmodificar].nombre);
       char nombre[100];
       scanf("%s",nombre);
   // Solicitamos el nuevo telefono
       printf("Introduce el nuevo telefono del contacto: (anterior: %s) \n",agenda[idmodificar].telefono);
       char telefono[100];
       scanf("%s",telefono);
   // Solicitamos el nuevo email
       printf("Introduce el nuevo email del contacto: (anterior: %s) \n",agenda[idmodificar].email);
       char email[100];
       scanf("%s",email);
   // Creamos una nueva estructura
       strcpy(agenda[idmodificar].nombre,nombre);
       strcpy(agenda[idmodificar].telefono,telefono);
       strcpy(agenda[idmodificar].email,email);
   // Feedback al usuario
       printf("Registro añadido, pulsa una tecla para volver al menu inicial \n");
       getchar();
       getchar();
   // Volvemos al menu principal
       printf("\033[2J");
       menuPrincipal();
   
}
	



17.2.3. Buscar Registro
El archivo de búsqueda de registros:
* Informa al usuario de la operación a realizar
* Solicita un dato (en este caso, el nombre del contacto)
* Recorre la matriz en busca de una coincidencia exacta
* En caso positivo, devuelve los datos de la coincidencia en pantalla
* Permite al usuario volver al menú principal
📂proyectodelcurso/  📂libAgenda/ 📄buscarRegistro.c
	// buscarRegistro.c
void buscarRegistro(){
   printf("\033[2J");
   // Mensaje informativo para el usuario
       printf("Vamos a buscar un registro \n");
   // Introducimos el nombre a buscar
       printf("Introduce el nombre del contacto: \n");
       char nombre[100];
       scanf("%c",nombre);
   // Recorremos la matriz registro a registro, comparando la cadena
       for(int i = 1;i<=longitudDatos;i++){
           if(strcmp(nombre,agenda[i].nombre) != 0){
               printf("Registro: %s %s %s \n",agenda[i].nombre,agenda[i].telefono,agenda[i].email);
           }
       }
   // Volvemos al menu principal
       printf("Pulsa Enter para volver al menu principal");
       getchar();
       getchar();
       printf("\033[2J");
       menuPrincipal();
}
	



17.2.4. Obtener la fecha
El archivo encargado de obtener la fecha:
* Incluye la librería de gestión de fechas
* Crea una nueva instancia del objeto time
* Obtiene los datos de la fecha actual
* Los devuelve en pantalla formateados en un string


📂proyectodelcurso/  📂libAgenda/ 📄dameFecha.c
	// dameFecha.c
#include <stdio.h>
#include <time.h>

void dameFecha() {
   time_t t = time(NULL);
   struct tm tm = *localtime(&t);
   printf(
       "hoy es: %d-%d-%d %d:%d:%d\n", 
       tm.tm_year + 1900, 
       tm.tm_mon + 1, 
       tm.tm_mday, 
       tm.tm_hour, 
       tm.tm_min, 
       tm.tm_sec
       );
}
	



17.2.5. Datos de partida
El archivo del menú principal:
* Declara la función del menú principal, ya que es el primer archivo en ser llamado desde el archivo main, para que la función exista en la memoria y no de un error de bucle
* Crea una estructura con tres propiedades iniciales, nombre, teléfono, e email
* Crea una colección de registros de tipo RegistroAgenda (nuestro programa será capaz de albergar a un máximo de 100 registros
* Introduce un cursor de longitud de datos con el valor de 3. Esto es debido a que nuestro programa arranca con 3 registros iniciales
📂proyectodelcurso/  📂libAgenda/ 📄datos.c
	// datos.c

void menuPrincipal();
struct RegistroAgenda{
       char nombre[50];
       char telefono[50];
       char email[50];
   };
   
   struct RegistroAgenda agenda[100];
   
   int longitudDatos = 3;
	



17.2.6. Eliminar Registro
El archivo de eliminación de registros:
* Anuncia la operación que va a realizar
* Solicita al usuario el identificador del registro a eliminar (índice del arreglo)
* Para cada uno de los registros a partir del registro seleccionado, los copia en el anterior (sobre escribe)
* Reduce en una unidad la longitud de los datos
* Permite al usuario volver al menú principal
📂proyectodelcurso/  📂libAgenda/ 📄eliminarRegistro.c
	// eliminarRegistro.c
void eliminarRegistro(){
   printf("\033[2J");
   // Mensaje informativo para el usuario
       printf("Vamos a eliminar un registro");
   // Solicitamos el id a eliminar
       printf("Introduce el id del registro a eliminar: \n");
       getchar();
       int id = getchar();
   // Recorremos la matriz copiando el siguiente registro, en el anterior, a partir del registro indicado
       for(int i = id;i<longitudDatos;i++){
           agenda[i] = agenda[i+1];
       }
   // Recortamos la longitud de los datos
       longitudDatos--;
   // Volvemos al menu inicial
       printf("Pulsa Enter para volver al menu principal");
       getchar();
       getchar();
       printf("\033[2J");
       menuPrincipal();
}
	



17.2.7. Guardar Datos
El archivo de guardado de datos, contiene el siguiente código:
* Crea una nueva llamada a un archivo
* Inserta cada uno de los registros del arreglo en el archivo
* Cierra el archivo
* Permite al usuario volver al menú principal
📂proyectodelcurso/  📂libAgenda/ 📄guardarDatos.c
	// guardarDatos.c
void guardarDatos(){
   printf("\033[2J");
   // Creamos un archivo
   FILE *archivo;
   archivo = fopen("agenda.txt","w");
   // Recorremos los registros uno a uno, los mostramos por pantalla
   for(int i = 1; i<=longitudDatos;i++){
       fprintf(archivo,"%s|%s|%s \n",agenda[i].nombre,agenda[i].telefono,agenda[i].email);
   }
   fclose(archivo);
   // Volvemos al menu principal
   printf("Pulsa Enter para volver al menú principal \n");
   getchar();
   getchar();
   printf("\033[2J");
   menuPrincipal();
}
	



17.2.8. Introducir Registro
El archivo que gestiona la introducción de los registros:
* Anuncia al usuario la acción a realizar
* Le solicita, uno a uno, los datos del nuevo usuario
* Aumenta una unidad al índice del cursor del arreglo
* Copia los datos introducidos por el usuario en ese cursor dentro del arreglo
* Permite al usuario volver al menú principal
📂proyectodelcurso/  📂libAgenda/ 📄introducirRegistro.c
	// introducirRegistro.c
void introducirRegistro(){
   printf("\033[2J");
   // Información al usuario
       printf("Vamos a introducir un registro \n");
   // Solicitamos el nombre
       printf("Indica el nombre del contacto: \n");
       char nombre[100];
       scanf("%s",nombre);
   // Solicitamos el telefono
       printf("Indica el telefono del contacto: \n");
       char telefono[100];
       scanf("%s",telefono);
   // Solicitamos el email
       printf("Indica el email del contacto: \n");
       char email[100];
       scanf("%s",email);
   // Aumentamos el indice de la matriz
       longitudDatos++;
   // Creamos una nueva estructura
       strcpy(agenda[longitudDatos].nombre,nombre);
       strcpy(agenda[longitudDatos].telefono,telefono);
       strcpy(agenda[longitudDatos].email,email);
   // Feedback al usuario
       printf("Registro añadido, pulsa una tecla para volver al menu inicial \n");
       getchar();
       getchar();
   // Volvemos al menu principal
       printf("\033[2J");
       menuPrincipal();
   
}
	



17.2.9. Listar los registros
El archivo encargado de listar los registros:
* Recorre el array elemento a elemento
* Imprime los datos de ese registro por pantalla
* Permite al usuario volver a la pantalla anterior
📂proyectodelcurso/  📂libAgenda/ 📄listadoRegistros.c
	// listadoRegistros.c
void listadoRegistros(){
   printf("\033[2J");
   // Recorremos los registros uno a uno, los mostramos por pantalla
   for(int i = 1; i<=longitudDatos;i++){
       printf("Registro: %s %s %s \n",agenda[i].nombre,agenda[i].telefono,agenda[i].email);
   }
   // Volvemos al menu principal
   printf("Pulsa Enter para volver al menú principal \n");
   getchar();
   getchar();
   printf("\033[2J");
   menuPrincipal();
}
	



17.2.10. Menú Principal
El archivo correspondiente al menú principal:
* Arroja un mensaje de bienvenida por pantalla
* Le informa al usuario de las opciones posibles
* Le pide al usuario introducir una opción
* Atrapa la entrada del usuario y llama a la función correspondiente
* En el caso de que el dato introducido por el usuario no sea válido, le permite volver al menú principal
📂proyectodelcurso/  📂libAgenda/ 📄menuPrincipal.c
	// menuPrincipal.c
void menuPrincipal(){
        printf("\033[2J");
    // Mensaje de bienvenida
        printf("%s v%s \n",NOMBREPROGRAMA,VERSION);
        printf("%s \n",AUTOR);
        dameFecha();
        printf("\t 1 - Listado de registros \n");
        printf("\t 2 - Introducir un registro \n");
        printf("\t 3 - Eliminar un registro \n");
        printf("\t 4 - Buscar un registro \n");
        printf("\t 5 - Actualizar un registro \n");
        printf("\t 6 - Guardar datos en un archivo \n");
        printf("\t 7 - Recuperar datos desde un archivo \n");
        printf("Tu opcion: ");
        char opcion = getchar();
        printf("La opción que has seleccionado es: %c \n",opcion);
        switch(opcion){
            case '1':
                listadoRegistros();
                break;
       case '2':
                introducirRegistro();
                break;
       case '3':
                eliminarRegistro();
                break;
       case '4':
                buscarRegistro();
                break;
            case '5':
                actualizarRegistro();
                break;
      case '6':
                guardarDatos();
                break;
      case '7':
                recuperarDatos();
                break;
       default:
           printf("La opción que has introducido no es válida");
            printf("Pulsa Enter para volver al menú principal \n");
                    getchar();
                    getchar();
                    printf("\033[2J");
                    menuPrincipal();
           
           break;
        }
}
	



17.2.11. Recuperar Datos
El archivo de recuperación de datos desde el disco duro:
* Establece un caracter delimitador, acorde al mismo delimitador definido en el archivo de escritura de registros
* Abre el archivo de la agenda en modo lectura
* Lee el archivo línea a línea
* Trata la cadena de datos, parte en diferentes datos, y los introduce en la memoria del programa
* Permite al usuario volver al menú principal
📂proyectodelcurso/  📂libAgenda/ 📄recuperarDatos.c
	// recuperarDatos.c
void recuperarDatos(){
       printf("\033[2J");
   // Declaraciones iniciales
       char cadena[80];
      const char delimitador[2] = "|";
      char *partido;
      FILE *archivo;
  // Abrimos un archivo
   archivo = fopen("agenda.txt","r");
  // Leemos el archivo linea a linea
       while( fgets (cadena, 60, archivo)!=NULL ){
           // Partimos lineas a structs
               partido = strtok(cadena, delimitador);
               int contador = 0;
               longitudDatos++;
               while( partido != NULL ) {
                 if(contador == 0){strcpy(agenda[longitudDatos].nombre,partido);}
                 if(contador == 1){strcpy(agenda[longitudDatos].telefono,partido);}
                 if(contador == 2){strcpy(agenda[longitudDatos].email,partido);}
                 partido = strtok(NULL, delimitador);
                 contador++;
              }
       }
  // Feedback al usuario
       printf("Registros cargados, pulsa una tecla para volver al menu inicial \n");
       getchar();
       getchar();
   // Volvemos al menu principal
       printf("\033[2J");
       menuPrincipal();
  
}
	17.3. Ejecución
Una vez que hemos expuesto el código fuente de las partes principales del programa, a continuación vamos a mostrar una secuencia de ejecución del mismo
17.3.1. Compilación
En primer lugar, compilamos el programa. En este caso se muestra un ejemplo de compilación en entorno macOS. 
iMac-de-Jose:proyectocurso josevicente$ gcc main.c -o agenda
iMac-de-Jose:proyectocurso josevicente$ 
	

en el caso de tratarse de un entorno Windows, se llamaría al compilador usando el comando gcc.exe, y el archivo de salida (output) tendría la extensión .exe (siendo agenda.exe)
17.3.2. Ejecución
Una vez que el programa ha sido compilado, lo ejecutaremos - el siguiente ejemplo muestra la ejecución en sistemas macOS/Linux. En un sistema Windows, la llamada sería al archivo ejecutable agenda.exe


iMac-de-Jose:proyectocurso josevicente$ ./agenda 
	

17.3.3. El programa en funcionamiento
En primer lugar, el programa mostrará el menú principal, del cual elegiremos la primera opción


Programa agenda v1.0 
Jose Vicente Carratala 
hoy es: 2023-2-24 21:42:41
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
         6 - Guardar datos en un archivo 
         7 - Recuperar datos desde un archivo 
Tu opcion: 1
	Al elegir la primera opción, mostrará los registros contenidos por defecto, por pantalla.
Registro: Jose Vicente 12345678 info@josevicentecarratala.com 
Registro: Juan 53254 juan@josevicentecarratala.com 
Registro: Jaime 64566 jaime@josevicentecarratala.com 
Pulsa Enter para volver al menú principal 
	

Al pulsar sobre la tecla Enter, podremos volver al menú principal, en el que elegiremos explorar la segunda opción
Programa agenda v1.0 
Jose Vicente Carratala 
hoy es: 2023-2-24 21:43:29
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
         6 - Guardar datos en un archivo 
         7 - Recuperar datos desde un archivo 
Tu opcion: 2
	En la segunda opción, introduciremos los datos correspondientes a un nuevo registro, tras lo cual podremos volver al menú principal. Si, al volver, elegimos listar los registros, podremos comprobar como el nuevo registro ha quedado guardado en la memoria.
Vamos a introducir un registro 
Indica el nombre del contacto: 
Jorge
Indica el telefono del contacto: 
Lopez
Indica el email del contacto: 
jorge@lopez.com
Registro añadido, pulsa una tecla para volver al menu inicial 
	

Al volver al menú principal, elegiremos, en esta ocasión, la tercera opción


Programa agenda v1.0 
Jose Vicente Carratala 
hoy es: 2023-2-24 21:43:29
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
         6 - Guardar datos en un archivo 
         7 - Recuperar datos desde un archivo 
Tu opcion: 3
	Una vez que indicamos el identificador a eliminar, el programa eliminará el registro del arreglo que corresponda a ese índice.
Vamos a eliminar un registroIntroduce el id del registro a eliminar: 
1
Pulsa Enter para volver al menu principal
	En el menú principal, elegiremos la quinta opción
Programa agenda v1.0 
Jose Vicente Carratala 
hoy es: 2023-2-24 21:44:4
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
         6 - Guardar datos en un archivo 
         7 - Recuperar datos desde un archivo 
Tu opcion: 5
	Para actualizar un registro, introduciremos todos los datos de ese registro concreto - notemos como el sistema nos muestra los datos anteriores
Vamos a actualizar un registro 
Introduce el id del contacto: 
1
Has introducido el id para modificar: 1 
Introduce el nuevo nombre del contacto: (anterior: Jose Vicente) 
JV
Introduce el nuevo telefono del contacto: (anterior: 12345678) 
1234
Introduce el nuevo email del contacto: (anterior: info@josevicentecarratala.com) 
info@josevicente.com
Registro añadido, pulsa una tecla para volver al menu inicial 
	En el menú inicial, elegimos guardar los datos a un archivo de texto
Programa agenda v1.0 
Jose Vicente Carratala 
hoy es: 2023-2-24 21:44:36
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
         6 - Guardar datos en un archivo 
         7 - Recuperar datos desde un archivo 
Tu opcion: 6
	Tras lo cual podemos volver al menú inicial
Pulsa Enter para volver al menú principal
	Por último cargamos los registros desde un archivo de texto
Programa agenda v1.0 
Jose Vicente Carratala 
hoy es: 2023-2-24 21:44:55
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
         6 - Guardar datos en un archivo 
         7 - Recuperar datos desde un archivo 
Tu opcion: 7
	El programa nos informa de que los registros han quedado correctamente cargados, tras lo cual volvemos al menú inicial
Registros cargados, pulsa una tecla para volver al menu inicial
	Y, tras haber realizado estas operaciones, comprobamos que el programa que hemos desarrollado es completamente funcional
Programa agenda v1.0 
Jose Vicente Carratala 
hoy es: 2023-2-24 21:45:16
         1 - Listado de registros 
         2 - Introducir un registro 
         3 - Eliminar un registro 
         4 - Buscar un registro 
         5 - Actualizar un registro 
         6 - Guardar datos en un archivo 
         7 - Recuperar datos desde un archivo 
Tu opcion: 
	





















________________


18. Epílogo


________________


Mi deseo es que, al finalizar este libro, hayas aprendido a crear programas con el lenguaje C, al menos a un nivel inicial, y que hayas adquirido los suficientes conocimientos como para asentar una base sólida de conocimiento que te permita seguir creciendo y profundizando en las características de este lenguaje de programación.
Deseo que esos conocimientos te permitan construir aplicaciones, y que esas aplicaciones mejoren la vida de las personas que las usen en algún aspecto o en otro. Y también, por supuesto, que la capacidad de crear esas aplicaciones te traiga prosperidad en tu carrera profesional y autorrealizacion por poder crear herramientas que otras personas utilicen.
A lo largo de las últimas décadas, este lenguaje de programación ha contribuido a crear infinidad de programas informáticos, muchos de ellos probablemente los uses cotidianamente. Igualmente, ha contribuido a crear otros lenguajes que, en mayor o menor medida, se han inspirado en su sintaxis y en sus capacidades. Deseo que, al igual que C ha posibilitado la creación de una enorme cantidad de proyectos, también te sirva a ti para crear los tuyos propios.
Hoy, C se sitúa entre los lenguajes más utilizados y más populares, y lejos de caer en el desuso, se mantiene estable en el tiempo, constituyendo una tecnología segura en la que desarrollar nuevas aplicaciones.
Ahora, es el momento de pensar qué quieres hacer con este lenguaje de programación. El futuro está por llegar, y, aunque no lo parezca, todo está todavía por inventar. Este lenguaje, como otros muchos, no es más que una herramienta para convertir en realidad ese futuro.








________________